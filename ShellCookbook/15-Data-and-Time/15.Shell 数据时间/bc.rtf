{\rtf1\fbidis\ansi\ansicpg0\uc1\deff0\deflang2052\deflangfe2052{\fonttbl{\f0\fnil\fcharset134 \'cb\'ce\'cc\'e5;}{\f1\fnil Arial;}{\f2\fnil \'ce\'a2\'c8\'ed\'d1\'c5\'ba\'da;}{\f3\fnil\fcharset2 Symbol;}}{\colortbl;\red0\green0\blue255;\red0\green0\blue128;\red128\green0\blue0;\red0\green128\blue0;\red0\green0\blue0;\red0\green128\blue128;\red255\green0\blue0;\red255\green255\blue255;}{\*\listtable{\list\listtemplateid1072839502\listsimple1
{\listlevel\levelnfc23\leveljc0\li720\fi-360\jclisttab\tx720{\leveltext\'01\uc2\u183 \'a1\'a4\uc1;}{\levelnumbers;}\f3\fs24\lang1024}
\listid1958978184}
}
{\*\listoverridetable
{\listoverride\listid1958978184\listoverridecount0\ls1}
}


\pard\fi0\li0\qc\ri0\sb0\sa0\itap0 \plain \f0\b\fs24\cf5 bc
\par \pard\fi0\li0\ql\ri0\sb0\sa0\itap0 
\par \plain \f2\fs20\cf5 Bash\uc2\u20869 \'c4\'da\u32622 \'d6\'c3\u20102 \'c1\'cb\u23545 \'b6\'d4\u25972 \'d5\'fb\u25968 \'ca\'fd\u22235 \'cb\'c4\u21017 \'d4\'f2\u36816 \'d4\'cb\u31639 \'cb\'e3\u30340 \'b5\'c4\u25903 \'d6\'a7\u25345 \'b3\'d6\u65292 \'a3\'ac\u20294 \'b5\'ab\u26159 \'ca\'c7\u24182 \'b2\'a2\u19981 \'b2\'bb\u25903 \'d6\'a7\u25345 \'b3\'d6\u28014 \'b8\'a1\u28857 \'b5\'e3\u36816 \'d4\'cb\u31639 \'cb\'e3\u65292 \'a3\'ac\u32780 \'b6\'f8\uc1\plain \f2\fs20\cf1 bc\uc2\u21629 \'c3\'fc\u20196 \'c1\'ee\u21487 \'bf\'c9\u20197 \'d2\'d4\u24456 \'ba\'dc\u26041 \'b7\'bd\u20415 \'b1\'e3\u30340 \'b5\'c4\u36827 \'bd\'f8\u34892 \'d0\'d0\u28014 \'b8\'a1\u28857 \'b5\'e3\u36816 \'d4\'cb\u31639 \'cb\'e3\u65292 \'a3\'ac\u24403 \'b5\'b1\u28982 \'c8\'bb\u25972 \'d5\'fb\u25968 \'ca\'fd\u36816 \'d4\'cb\u31639 \'cb\'e3\u20063 \'d2\'b2\u19981 \'b2\'bb\u20877 \'d4\'d9\u35805 \'bb\'b0\u19979 \'cf\'c2\u12290 \'a1\'a3\uc1
\par \plain \f2\fs20\cf5 \uc2\u25163 \'ca\'d6\u20876 \'b2\'e1\u39029 \'d2\'b3\u19978 \'c9\'cf\u35828 \'cb\'b5\uc1\plain \f2\fs20\cf7 bc\uc2\u26159 \'ca\'c7An arbitrary precision calculator language\u65292 \'a3\'ac\u21363 \'bc\'b4\u19968 \'d2\'bb\u20010 \'b8\'f6\u20219 \'c8\'ce\u24847 \'d2\'e2\u31934 \'be\'ab\u24230 \'b6\'c8\u30340 \'b5\'c4\u35745 \'bc\'c6\u31639 \'cb\'e3\u35821 \'d3\'ef\u35328 \'d1\'d4\u12290 \'a1\'a3\uc1
\par \plain \f2\fs20\cf-1 \uc2\u27880 \'d7\'a2\u24847 \'d2\'e2\u26159 \'ca\'c7\u19968 \'d2\'bb\u31181 \'d6\'d6\u35821 \'d3\'ef\u35328 \'d1\'d4\uc1\plain \f2\fs20\cf5 \uc2\u65292 \'a3\'ac\u23427 \'cb\'fc\u25552 \'cc\'e1\u20379 \'b9\'a9\u20102 \'c1\'cb\u19968 \'d2\'bb\u20123 \'d0\'a9\u35821 \'d3\'ef\u27861 \'b7\'a8\u32467 \'bd\'e1\u26500 \'b9\'b9\u65292 \'a3\'ac\u27604 \'b1\'c8\u22914 \'c8\'e7\u26465 \'cc\'f5\u20214 \'bc\'fe\u21028 \'c5\'d0\u26029 \'b6\'cf\u12289 \'a1\'a2\u24490 \'d1\'ad\u29615 \'bb\'b7\u31561 \'b5\'c8\u65292 \'a3\'ac\u21487 \'bf\'c9\u20197 \'d2\'d4\u35828 \'cb\'b5\u26159 \'ca\'c7\u24456 \'ba\'dc\u24378 \'c7\'bf\u22823 \'b4\'f3\u30340 \'b5\'c4\u65292 \'a3\'ac\u21478 \'c1\'ed\u22806 \'cd\'e2\u19968 \'d2\'bb\u20010 \'b8\'f6\u29992 \'d3\'c3\u36884 \'cd\'be\u23601 \'be\'cd\u26159 \'ca\'c7\u29992 \'d3\'c3\u26469 \'c0\'b4\u36827 \'bd\'f8\u34892 \'d0\'d0\u36827 \'bd\'f8\u21046 \'d6\'c6\u36716 \'d7\'aa\u25442 \'bb\'bb\u12290 \'a1\'a3\uc1
\par 
\par \plain \f2\fs20\cf-1 bc\uc2\u26159 \'ca\'c7\u22522 \'bb\'f9\u20110 \'d3\'da\u23383 \'d7\'d6\u31526 \'b7\'fb\u30340 \'b5\'c4\u35745 \'bc\'c6\u31639 \'cb\'e3\u22120 \'c6\'f7\u31243 \'b3\'cc\u24207 \'d0\'f2\u65292 \'a3\'acbc\u21487 \'bf\'c9\u20197 \'d2\'d4\u22788 \'b4\'a6\u29702 \'c0\'ed\u24456 \'ba\'dc\u22823 \'b4\'f3\u30340 \'b5\'c4\u25972 \'d5\'fb\u25968 \'ca\'fd\u65292 \'a3\'acbc\u36824 \'bb\'b9\u26159 \'ca\'c7\u21487 \'bf\'c9\u32534 \'b1\'e0\u31243 \'b3\'cc\u30340 \'b5\'c4\u65292 \'a3\'ac\u26377 \'d3\'d0\u36923 \'c2\'df\u36753 \'bc\'ad\u21028 \'c5\'d0\u26029 \'b6\'cf\u21644 \'ba\'cd\u24490 \'d1\'ad\u29615 \'bb\'b7\u32467 \'bd\'e1\u26500 \'b9\'b9\u65292 \'a3\'ac\u35821 \'d3\'ef\u27861 \'b7\'a8\u19982 \'d3\'ebC\u35821 \'d3\'ef\u35328 \'d1\'d4\u31867 \'c0\'e0\u20284 \'cb\'c6\u12290 \'a1\'a3\uc1
\par \plain \f2\fs20\cf6 -----------------------------------------------------------------------------------------------------
\par \plain \f2\b\fs20\cf5 \uc2\u24120 \'b3\'a3\u29992 \'d3\'c3\u21442 \'b2\'ce\u25968 \'ca\'fd\uc1
\par \plain \f2\fs20\cf5 \uc2\u19968 \'d2\'bb\u33324 \'b0\'e3\u24773 \'c7\'e9\u20917 \'bf\'f6\u19979 \'cf\'c2\u65292 \'a3\'ac\u25105 \'ce\'d2\u20204 \'c3\'c7\u20351 \'ca\'b9\u29992 \'d3\'c3\u19981 \'b2\'bb\u24102 \'b4\'f8\u20219 \'c8\'ce\u20309 \'ba\'ce\u21442 \'b2\'ce\u25968 \'ca\'fd\u30340 \'b5\'c4bc\u21629 \'c3\'fc\u20196 \'c1\'ee\u65306 \'a3\'ba\uc1
\par bc
\par 
\par \plain \f2\fs20\cf1 \uc2\u22914 \'c8\'e7\u26524 \'b9\'fb\u38656 \'d0\'e8\u35201 \'d2\'aabc\u19981 \'b2\'bb\u36755 \'ca\'e4\u20986 \'b3\'f6\u25552 \'cc\'e1\u31034 \'ca\'be\u20449 \'d0\'c5\u24687 \'cf\'a2\u65292 \'a3\'ac\u21487 \'bf\'c9\u20197 \'d2\'d4\u21152 \'bc\'d3\u19978 \'c9\'cf-q\u21442 \'b2\'ce\u25968 \'ca\'fd\u65306 \'a3\'ba\uc1
\par \plain \f2\fs20\cf5 bc -q
\par 
\par \plain \f2\fs20\cf7 \uc2\u22914 \'c8\'e7\u26524 \'b9\'fb\u35201 \'d2\'aa\u20351 \'ca\'b9\u29992 \'d3\'c3\u24378 \'c7\'bf\u22823 \'b4\'f3\u30340 \'b5\'c4\u25968 \'ca\'fd\u23398 \'d1\'a7\u24211 \'bf\'e2\u65292 \'a3\'ac\u27604 \'b1\'c8\u22914 \'c8\'e7\u35745 \'bc\'c6\u31639 \'cb\'e3\u19977 \'c8\'fd\u35282 \'bd\'c7\u20989 \'ba\'af\u25968 \'ca\'fd\u65292 \'a3\'ac\u38656 \'d0\'e8\u35201 \'d2\'aa\u21152 \'bc\'d3\u19978 \'c9\'cf-l\u21442 \'b2\'ce\u25968 \'ca\'fd\u65306 \'a3\'ba\uc1
\par \plain \f2\fs20\cf5 bc -l
\par 
\par \plain \f2\fs20\cf7 \uc2\u22240 \'d2\'f2\u20026 \'ce\'aabc\u26412 \'b1\'be\u36523 \'c9\'ed\u26159 \'ca\'c7\u19968 \'d2\'bb\u20010 \'b8\'f6\u21629 \'c3\'fc\u20196 \'c1\'ee\u35299 \'bd\'e2\u37322 \'ca\'cd\u22120 \'c6\'f7\uc1\plain \f2\fs20\cf5 \uc2\u65292 \'a3\'ac\u35201 \'d2\'aa\u36864 \'cd\'cb\u20986 \'b3\'f6\u23427 \'cb\'fc\u21482 \'d6\'bb\u35201 \'d2\'aa\u30452 \'d6\'b1\u25509 \'bd\'d3\u36755 \'ca\'e4\u20837 \'c8\'ebquit\u22238 \'bb\'d8\u36710 \'b3\'b5\u25110 \'bb\'f2\u32773 \'d5\'df\u25353 \'b0\'b4Ctrl+D\u32456 \'d6\'d5\u27490 \'d6\'b9\u12290 \'a1\'a3\uc1
\par \plain \f2\fs20\cf6 ----------------------------------------------------------------------------------------------------
\par \plain \f2\fs20\cf5 
\par bc(1)                                                                    bc(1)
\par 
\par NAME
\par \plain \f2\fs20\cf1        bc - An arbitrary\uc2\u65288 \'a3\'a8adj. [\u25968 \'ca\'fd] \u20219 \'c8\'ce\u24847 \'d2\'e2\u30340 \'b5\'c4\u65307 \'a3\'bb\u27494 \'ce\'e4\u26029 \'b6\'cf\u30340 \'b5\'c4\u65307 \'a3\'bb\u19987 \'d7\'a8\u21046 \'d6\'c6\u30340 \'b5\'c4\u65289 \'a3\'a9 precision calculator language\uc1
\par \plain \f2\fs20\cf5 
\par SYNTAX
\par        bc [ -hlwsqv ] [long-options] [  file ... ]
\par 
\par DESCRIPTION
\par        bc  is  a language that supports arbitrary precision numbers with interactive execution of statements.  There are
\par        some similarities in the syntax to the C programming language.  A standard math library is available  by  command
\par        line  option.   If  requested,  the math library is defined before processing any files.  bc starts by processing
\par        code from all the files listed on the command line in the order listed.  After all files have been processed,  bc
\par        reads  from  the  standard input.  All code is executed as it is read.  (If a file contains a command to halt the
\par        processor, bc will never read from the standard input.)
\par 
\par        This version of bc contains several extensions beyond traditional bc implementations and the  POSIX  draft  stan-
\par        dard.   Command  line  options  can  cause  these extensions to print a warning or to be rejected.  This document
\par        describes the language accepted by this processor.  Extensions will be identified as such.
\par 
\par    OPTIONS
\par        -h, --help
\par               Print the usage and exit.
\par 
\par \plain \f2\fs20\cf1        -i, --interactive
\par \plain \f2\fs20\cf5               Force interactive mode.
\par 
\par \plain \f2\fs20\cf1        -l, --mathlib
\par \plain \f2\fs20\cf5               \plain \f2\fs20\cf7 Define the standard math library.
\par \plain \f2\fs20\cf5 
\par        -w, --warn
\par               Give warnings for extensions to POSIX bc.
\par 
\par        -s, --standard
\par               Process exactly the POSIX bc language.
\par 
\par \plain \f2\fs20\cf7        -q, --quiet
\par \plain \f2\fs20\cf5               Do not print the normal GNU bc welcome.
\par 
\par        -v, --version
\par               Print the version number and copyright and quit.
\par 
\par    NUMBERS
\par        The most basic element in bc is the number.  Numbers are arbitrary precision numbers.  This precision is both  in
\par        the  integer part and the fractional part.  All numbers are represented internally in decimal and all computation
\par        is done in decimal.  (This version truncates results  from  divide  and  multiply  operations.)   There  are  two
\par        attributes of numbers, the length and the scale.  The length is the total number of significant decimal digits in
\par        a number and the scale is the total number of decimal digits after the decimal point.  For example:
\par                .000001 has a length of 6 and scale of 6.
\par                1935.000 has a length of 7 and a scale of 3.
\par 
\par    VARIABLES
\par        Numbers are stored in two types of variables, simple variables and arrays.  Both simple variables and array vari-
\par        ables  are named.  Names begin with a letter followed by any number of letters, digits and underscores.  All let-
\par        ters must be lower case.  (Full alpha-numeric names are an extension. In POSIX bc all names are  a  single  lower
\par        case  letter.)  The type of variable is clear by the context because all array variable names will be followed by
\par        brackets ([]).
\par 
\par        There are four special variables, scale, ibase, obase, and last.  scale defines how some  operations  use  digits
\par        after  the  decimal point.  The default value of scale is 0. ibase and obase define the conversion base for input
\par        and output numbers.  The default for both input and output is base 10.  last (an extension) is  a  variable  that
\par        has  the  value of the last printed number.  These will be discussed in further detail where appropriate.  All of
\par        these variables may have values assigned to them as well as used in expressions.
\par 
\par    COMMENTS
\par        Comments in bc start with the characters /* and end with the characters */.   Comments  may  start  anywhere  and
\par        appear  as a single space in the input.  (This causes comments to delimit other input items.  For example, a com-
\par        ment can not be found in the middle of a variable name.)  Comments include any newlines (end of line) between the
\par        start and the end of the comment.
\par 
\par        To  support  the use of scripts for bc, a single line comment has been added as an extension.  A single line com-
\par        ment starts at a # character and continues to the next end of the line.  The end of line character is not part of
\par        the comment and is processed normally.
\par 
\par    EXPRESSIONS
\par        The  numbers  are  manipulated by expressions and statements.  Since the language was designed to be interactive,
\par        statements and expressions are executed as soon as possible.  There is no "main" program.  Instead, code is  exe-
\par        cuted as it is encountered.  (Functions, discussed in detail later, are defined when encountered.)
\par 
\par        A  simple  expression  is  just a constant. bc converts constants into internal decimal numbers using the current
\par        input base, specified by the variable ibase. (There is an exception in functions.)  The legal values of ibase are
\par        2  through  16.   Assigning a value outside this range to ibase will result in a value of 2 or 16.  Input numbers
\par        may contain the characters 0-9 and A-F. (Note: They must be capitals.  Lower case letters  are  variable  names.)
\par        Single  digit  numbers  always  have the value of the digit regardless of the value of ibase. (i.e. A = 10.)  For
\par        multi-digit numbers, bc changes all input digits greater or equal to ibase to the value of ibase-1.   This  makes
\par        the number FFF always be the largest 3 digit number of the input base.
\par 
\par        Full  expressions  are similar to many other high level languages.  Since there is only one kind of number, there
\par        are no rules for mixing types.  Instead, there are rules on the scale of expressions.   Every  expression  has  a
\par        scale.   This is derived from the scale of original numbers, the operation performed and in many cases, the value
\par        of the variable scale. Legal values of the variable scale are 0 to the maximum number representable by a C  inte-
\par        ger.
\par 
\par        In  the following descriptions of legal expressions, "expr" refers to a complete expression and "var" refers to a
\par        simple or an array variable.  A simple variable is just a
\par               name
\par        and an array variable is specified as
\par               name[expr]
\par        Unless specifically mentioned the scale of the result is the maximum scale of the expressions involved.
\par 
\par        - expr The result is the negation of the expression.
\par 
\par        ++ var The variable is incremented by one and the new value is the result of the expression.
\par 
\par        -- var The variable is decremented by one and the new value is the result of the expression.
\par 
\par        var ++  The result of the expression is the value of the variable and then the variable is incremented by one.
\par 
\par        var -- The result of the expression is the value of the variable and then the variable is decremented by one.
\par 
\par        expr + expr
\par               The result of the expression is the sum of the two expressions.
\par 
\par        expr - expr
\par               The result of the expression is the difference of the two expressions.
\par 
\par        expr * expr
\par               The result of the expression is the product of the two expressions.
\par 
\par        expr / expr
\par               The result of the expression is the quotient of the two expressions.  The scale of the result is the value
\par               of the variable scale.
\par 
\par        expr % expr
\par               The  result of the expression is the "remainder" and it is computed in the following way.  To compute a%b,
\par               first a/b is computed to scale digits.  That result is used to compute a-(a/b)*b to the scale of the maxi-
\par               mum  of  scale+scale(b)  and  scale(a).   If  scale  is set to zero and both expressions are integers this
\par               expression is the integer remainder function.
\par 
\par        expr ^ expr
\par               The result of the expression is the value of the first raised to the second. The second expression must be
\par               an  integer.   (If  the  second expression is not an integer, a warning is generated and the expression is
\par               truncated to get an integer value.)  The scale of the result is scale if the exponent is negative.  If the
\par               exponent is positive the scale of the result is the minimum of the scale of the first expression times the
\par               value of the exponent and the maximum of scale and the scale of the first expression.  (e.g. scale(a^b)  =
\par               min(scale(a)*b,  max(  scale, scale(a))).)  It should be noted that expr^0 will always return the value of
\par               1.
\par 
\par        ( expr )
\par               This alters the standard precedence to force the evaluation of the expression.
\par 
\par        var = expr
\par               The variable is assigned the value of the expression.
\par 
\par        var <op>= expr
\par               This is equivalent to "var = var <op> expr" with the exception that the "var" part is evaluated only once.
\par               This can make a difference if "var" is an array.
\par 
\par        Relational  expressions  are  a  special  kind of expression that always evaluate to 0 or 1, 0 if the relation is
\par        false and 1 if the relation is true.  These may appear in any legal expression.  (POSIX bc  requires  that  rela-
\par        tional  expressions  are used only in if, while, and for statements and that only one relational test may be done
\par        in them.)  The relational operators are
\par 
\par        expr1 < expr2
\par               The result is 1 if expr1 is strictly less than expr2.
\par 
\par        expr1 <= expr2
\par               The result is 1 if expr1 is less than or equal to expr2.
\par 
\par        expr1 > expr2
\par               The result is 1 if expr1 is strictly greater than expr2.
\par 
\par        expr1 >= expr2
\par               The result is 1 if expr1 is greater than or equal to expr2.
\par 
\par        expr1 == expr2
\par               The result is 1 if expr1 is equal to expr2.
\par 
\par        expr1 != expr2
\par               The result is 1 if expr1 is not equal to expr2.
\par 
\par        Boolean operations are also legal.  (POSIX bc does NOT have boolean operations). The result of all boolean opera-
\par        tions are 0 and 1 (for false and true) as in relational expressions.  The boolean operators are:
\par 
\par        !expr  The result is 1 if expr is 0.
\par 
\par        expr && expr
\par               The result is 1 if both expressions are non-zero.
\par 
\par        expr || expr
\par               The result is 1 if either expression is non-zero.
\par 
\par        The expression precedence is as follows: (lowest to highest)
\par               || operator, left associative
\par               && operator, left associative
\par               ! operator, nonassociative
\par               Relational operators, left associative
\par               Assignment operator, right associative
\par               + and - operators, left associative
\par               *, / and % operators, left associative
\par               ^ operator, right associative
\par               unary - operator, nonassociative
\par               ++ and -- operators, nonassociative
\par 
\par        This precedence was chosen so that POSIX compliant bc programs will run correctly. This will cause the use of the
\par        relational and logical operators to have some unusual behavior when used with assignment  expressions.   Consider
\par        the expression:
\par               a = 3 < 5
\par 
\par        Most  C programmers would assume this would assign the result of "3 < 5" (the value 1) to the variable "a".  What
\par        this does in bc is assign the value 3 to the variable "a" and then compare 3 to 5.  It is best to use parenthesis
\par        when using relational and logical operators with the assignment operators.
\par 
\par        There  are  a few more special expressions that are provided in bc.  These have to do with user defined functions
\par        and standard functions.  They all appear as "name(parameters)".  See the section on functions  for  user  defined
\par        functions.  The standard functions are:
\par 
\par        length ( expression )
\par               The value of the length function is the number of significant digits in the expression.
\par 
\par        read ( )
\par               The read function (an extension) will read a number from the standard input, regardless of where the func-
\par               tion occurs.   Beware, this can cause problems with the mixing of data and program in the standard  input.
\par               The  best  use  for  this  function is in a previously written program that needs input from the user, but
\par               never allows program code to be input from the user.  The value of the read function is  the  number  read
\par               from the standard input using the current value of the variable ibase for the conversion base.
\par 
\par        scale ( expression )
\par               The value of the scale function is the number of digits after the decimal point in the expression.
\par 
\par        sqrt ( expression )
\par               The value of the sqrt function is the square root of the expression.  If the expression is negative, a run
\par               time error is generated.
\par 
\par    STATEMENTS
\par        Statements (as in most algebraic languages) provide the sequencing of expression evaluation.   In  bc  statements
\par        are  executed  "as  soon  as possible."  Execution happens when a newline in encountered and there is one or more
\par        complete statements.  Due to this immediate execution, newlines are very important in bc. In fact, both  a  semi-
\par        colon  and  a  newline are used as statement separators.  An improperly placed newline will cause a syntax error.
\par        Because newlines are statement separators, it is possible to hide a newline by  using  the  backslash  character.
\par        The  sequence  "\\<nl>",  where <nl> is the newline appears to bc as whitespace instead of a newline.  A statement
\par        list is a series of statements separated by semicolons and newlines.  The following is a list  of  bc  statements
\par        and what they do: (Things enclosed in brackets ([]) are optional parts of the statement.)
\par 
\par        expression
\par               This statement does one of two things.  If the expression starts with "<variable> <assignment> ...", it is
\par               considered to be an assignment statement.  If the expression is not an assignment statement,  the  expres-
\par               sion  is  evaluated  and  printed  to the output.  After the number is printed, a newline is printed.  For
\par               example, "a=1" is an assignment statement and "(a=1)" is an expression that has  an  embedded  assignment.
\par               All numbers that are printed are printed in the base specified by the variable obase. The legal values for
\par               obase are 2 through BC_BASE_MAX.  (See the section LIMITS.)  For bases 2 through 16, the usual  method  of
\par               writing  numbers  is  used.  For bases greater than 16, bc uses a multi-character digit method of printing
\par               the numbers where each higher base digit is printed as a base 10 number.  The multi-character  digits  are
\par               separated  by  spaces.   Each  digit  contains the number of characters required to represent the base ten
\par               value of "obase-1".  Since numbers are of arbitrary precision, some numbers may not be printable on a sin-
\par               gle  output  line.  These long numbers will be split across lines using the "\\" as the last character on a
\par               line.  The maximum number of characters printed per line is 70.  Due to  the  interactive  nature  of  bc,
\par               printing a number causes the side effect of assigning the printed value to the special variable last. This
\par               allows the user to recover the last value printed without having to retype the expression that printed the
\par               number.   Assigning  to  last  is legal and will overwrite the last printed value with the assigned value.
\par               The newly assigned value will remain until the next number is printed or  another  value  is  assigned  to
\par               last.   (Some  installations  may  allow the use of a single period (.) which is not part of a number as a
\par               short hand notation for for last.)
\par 
\par        string The string is printed to the output.  Strings start with a double quote character and contain all  charac-
\par               ters until the next double quote character.  All characters are take literally, including any newline.  No
\par               newline character is printed after the string.
\par 
\par        print list
\par               The print statement (an extension) provides another method of output.  The "list" is a list of strings and
\par               expressions  separated by commas.  Each string or expression is printed in the order of the list.  No ter-
\par               minating newline is printed.  Expressions are evaluated and their value is printed  and  assigned  to  the
\par               variable  last.  Strings  in the print statement are printed to the output and may contain special charac-
\par               ters.  Special characters start with the backslash character (\\).  The special characters recognized by bc
\par               are "a" (alert or bell), "b" (backspace), "f" (form feed), "n" (newline), "r" (carriage return), "q" (dou-
\par               ble quote), "t" (tab), and "\\" (backslash).  Any other character following the backslash will be  ignored.
\par 
\par        \{ statement_list \}
\par               This is the compound statement.  It allows multiple statements to be grouped together for execution.
\par 
\par        if ( expression ) statement1 [else statement2]
\par               The  if statement evaluates the expression and executes statement1 or statement2 depending on the value of
\par               the expression.  If the expression is non-zero, statement1 is executed.  If statement2 is present and  the
\par               value of the expression is 0, then statement2 is executed.  (The else clause is an extension.)
\par 
\par        while ( expression ) statement
\par               The while statement will execute the statement while the expression is non-zero.  It evaluates the expres-
\par               sion before each execution of the statement.   Termination of the loop is  caused  by  a  zero  expression
\par               value or the execution of a break statement.
\par 
\par        for ( [expression1] ; [expression2] ; [expression3] ) statement
\par               The for statement controls repeated execution of the statement.  Expression1 is evaluated before the loop.
\par               Expression2 is evaluated before each execution of the statement.  If it  is  non-zero,  the  statement  is
\par               evaluated.   If it is zero, the loop is terminated.  After each execution of the statement, expression3 is
\par               evaluated before the reevaluation of expression2.  If expression1 or expression3 are missing,  nothing  is
\par               evaluated at the point they would be evaluated.  If expression2 is missing, it is the same as substituting
\par               the value 1 for expression2.  (The optional expressions are an extension.  POSIX  bc  requires  all  three
\par               expressions.)  The following is equivalent code for the for statement:
\par               expression1;
\par               while (expression2) \{
\par                  statement;
\par                  expression3;
\par               \}
\par 
\par        break  This statement causes a forced exit of the most recent enclosing while statement or for statement.
\par 
\par        continue
\par               The  continue  statement  (an extension)  causes the most recent enclosing for statement to start the next
\par               iteration.
\par 
\par        halt   The halt statement (an extension) is an executed statement that causes the bc processor to quit only  when
\par               it  is  executed.   For example, "if (0 == 1) halt" will not cause bc to terminate because the halt is not
\par               executed.
\par 
\par        return Return the value 0 from a function.  (See the section on functions.)
\par 
\par        return ( expression )
\par               Return the value of the expression from a function.  (See the section on functions.)  As an extension, the
\par               parenthesis are not required.
\par 
\par    PSEUDO STATEMENTS
\par        These  statements are not statements in the traditional sense.  They are not executed statements.  Their function
\par        is performed at "compile" time.
\par 
\par        limits Print the local limits enforced by the local version of bc.  This is an extension.
\par 
\par        quit   When the quit statement is read, the bc processor is terminated, regardless of where the quit statement is
\par               found.  For example, "if (0 == 1) quit" will cause bc to terminate.
\par 
\par        warranty
\par               Print a longer warranty notice.  This is an extension.
\par 
\par    FUNCTIONS
\par        Functions  provide a method of defining a computation that can be executed later.  Functions in bc always compute
\par        a value and return it to the caller.  Function definitions are "dynamic" in the sense that a  function  is  unde-
\par        fined  until  a  definition  is  encountered in the input.  That definition is then used until another definition
\par        function for the same name is encountered.  The new definition then replaces the older definition.  A function is
\par        defined as follows:
\par               define name ( parameters ) \{ newline
\par                   auto_list   statement_list \}
\par        A function call is just an expression of the form "name(parameters)".
\par 
\par        Parameters are numbers or arrays (an extension).  In the function definition, zero or more parameters are defined
\par        by listing their names separated by commas.  All parameters are call by value parameters.  Arrays  are  specified
\par        in  the parameter definition by the notation "name[]".   In the function call, actual parameters are full expres-
\par        sions for number parameters.  The same notation is used for passing arrays as for defining array parameters.  The
\par        named  array  is  passed by value to the function.  Since function definitions are dynamic, parameter numbers and
\par        types are checked when a function is called.  Any mismatch in number or types of parameters will cause a  runtime
\par        error.  A runtime error will also occur for the call to an undefined function.
\par 
\par        The  auto_list  is  an  optional  list  of  variables  that are for "local" use.  The syntax of the auto list (if
\par        present) is "auto name, ... ;".  (The semicolon is optional.)  Each name is the name of an auto variable.  Arrays
\par        may be specified by using the same notation as used in parameters.  These variables have their values pushed onto
\par        a stack at the start of the function.  The variables are then initialized to zero and used throughout the  execu-
\par        tion  of  the  function.  At function exit, these variables are popped so that the original value (at the time of
\par        the function call) of these variables are restored.  The parameters are really auto variables that  are  initial-
\par        ized  to  a  value  provided in the function call.  Auto variables are different than traditional local variables
\par        because if function A calls function B, B may access function A\rquote s auto variables by just  using  the  same  name,
\par        unless  function B has called them auto variables.  Due to the fact that auto variables and parameters are pushed
\par        onto a stack, bc supports recursive functions.
\par 
\par        The function body is a list of bc statements.  Again, statements are separated by semicolons or newlines.  Return
\par        statements  cause  the termination of a function and the return of a value.  There are two versions of the return
\par        statement.  The first form, "return", returns the value 0 to the calling expression.  The second form, "return  (
\par        expression  )",  computes the value of the expression and returns that value to the calling expression.  There is
\par        an implied "return (0)" at the end of every function.  This allows a function to terminate and return  0  without
\par        an explicit return statement.
\par 
\par        Functions  also  change  the  usage  of the variable ibase.  All constants in the function body will be converted
\par        using the value of ibase at the time of the function call.  Changes of ibase will be ignored during the execution
\par        of  the function except for the standard function read, which will always use the current value of ibase for con-
\par        version of numbers.
\par 
\par        Several extensions have been added to functions.  First, the format of the definition has been slightly  relaxed.
\par        The  standard requires the opening brace be on the same line as the define keyword and all other parts must be on
\par        following lines.  This version of bc will allow any number of newlines before and after the opening brace of  the
\par        function.  For example, the following definitions are legal.
\par 
\par               define d (n) \{ return (2*n); \}
\par               define d (n)
\par                 \{ return (2*n); \}
\par 
\par        Functions  may  be  defined  as void.  A void funtion returns no value and thus may not be used in any place that
\par        needs a value.  A void function does not produce any output when called by itself on an input line.  The key word
\par        void is placed between the key word define and the function name.  For example, consider the following session.
\par 
\par               define py (y) \{ print "--->", y, "<---", "0; \}
\par               define void px (x) \{ print "--->", x, "<---", "0; \}
\par               py(1)
\par               --->1<---
\par               0
\par               px(1)
\par               --->1<---
\par        Since  py  is not a void function, the call of py(1) prints the desired output and then prints a second line that
\par        is the value of the function.  Since the value of a function that is not given an explicit  return  statement  is
\par        zero, the zero is printed.  For px(1), no zero is printed because the function is a void function.
\par 
\par        Also,  call  by variable for arrays was added.  To declare a call by variable array, the declaration of the array
\par        parameter in the function definition looks like "*name[]".  The call to the function remains the same as call  by
\par        value arrays.
\par 
\par    MATH LIBRARY
\par        If  bc  is invoked with the -l option, a math library is preloaded and the default scale is set to 20.   The math
\par        functions will calculate their results to the scale set at the time of their call.  The math library defines  the
\par        following functions:
\par 
\par        s (x)  The sine of x, x is in radians.
\par 
\par        c (x)  The cosine of x, x is in radians.
\par 
\par        a (x)  The arctangent of x, arctangent returns radians.
\par 
\par        l (x)  The natural logarithm of x.
\par 
\par        e (x)  The exponential function of raising e to the value x.
\par 
\par        j (n,x)
\par               The Bessel function of integer order n of x.
\par 
\par    EXAMPLES
\par        In /bin/sh,  the following will assign the value of "pi" to the shell variable pi.
\par 
\par      \plain \f2\fs20\cf7          pi=$(echo "scale=10; 4*a(1)" | bc -l)
\par \plain \f2\fs20\cf5 
\par        The  following  is the definition of the exponential function used in the math library.  This function is written
\par        in POSIX bc.
\par 
\par               scale = 20
\par 
\par               /* Uses the fact that e^x = (e^(x/2))^2
\par                  When x is small enough, we use the series:
\par                    e^x = 1 + x + x^2/2! + x^3/3! + ...
\par               */
\par 
\par               define e(x) \{
\par                 auto  a, d, e, f, i, m, v, z
\par 
\par                 /* Check the sign of x. */
\par                 if (x<0) \{
\par                   m = 1
\par                   x = -x
\par                 \}
\par 
\par                 /* Precondition x. */
\par                 z = scale;
\par                 scale = 4 + z + .44*x;
\par                 while (x > 1) \{
\par                   f += 1;
\par                   x /= 2;
\par                 \}
\par 
\par                 /* Initialize the variables. */
\par                 v = 1+x
\par                 a = x
\par                 d = 1
\par 
\par                 for (i=2; 1; i++) \{
\par                   e = (a *= x) / (d *= i)
\par                   if (e == 0) \{
\par                     if (f>0) while (f--)  v = v*v;
\par                     scale = z
\par                     if (m) return (1/v);
\par                     return (v/1);
\par                   \}
\par                   v += e
\par                 \}
\par               \}
\par 
\par        The following is code that uses the extended features of bc to implement a simple program for calculating  check-
\par        book balances.  This program is best kept in a file so that it can be used many times without having to retype it
\par        at every use.
\par 
\par               scale=2
\par               print "\\nCheck book program!\\n"
\par               print "  Remember, deposits are negative transactions.\\n"
\par               print "  Exit by a 0 transaction.\\n\\n"
\par 
\par               print "Initial balance? "; bal = read()
\par               bal /= 1
\par               print "\\n"
\par               while (1) \{
\par                 "current balance = "; bal
\par                 "transaction? "; trans = read()
\par                 if (trans == 0) break;
\par                 bal -= trans
\par                 bal /= 1
\par               \}
\par               quit
\par 
\par        The following is the definition of the recursive factorial function.
\par 
\par               define f (x) \{
\par                 if (x <= 1) return (1);
\par                 return (f(x-1) * x);
\par               \}
\par 
\par    READLINE AND LIBEDIT OPTIONS
\par        GNU bc can be compiled (via a configure option) to use the GNU readline input editor library or the  BSD  libedit
\par        library.  This allows the user to do editing of lines before sending them to bc.  It also allows for a history of
\par        previous lines typed.  When this option is selected, bc has one more special variable.   This  special  variable,
\par        history  is  the number of lines of history retained.  For readline, a value of -1 means that an unlimited number
\par        of history lines are retained.  Setting the value of history to a positive number restricts the number of history
\par        lines  to  the  number  given.   The value of 0 disables the history feature.  The default value is 100. For more
\par        information, read the user manuals for the GNU readline, history and BSD libedit libraries.  One can  not  enable
\par        both readline and libedit at the same time.
\par 
\par    DIFFERENCES
\par        This  version  of bc was implemented from the POSIX P1003.2/D11 draft and contains several differences and exten-
\par        sions relative to the draft and traditional implementations.  It is not implemented in the traditional way  using
\par        dc(1).   This version is a single process which parses and runs a byte code translation of the program.  There is
\par        an "undocumented" option (-c) that causes the program to output the byte code to the standard output  instead  of
\par        running it.  It was mainly used for debugging the parser and preparing the math library.
\par 
\par        A major source of differences is extensions, where a feature is extended to add more functionality and additions,
\par        where new features are added.  The following is the list of differences and extensions.
\par 
\par        LANG environment
\par               This version does not conform to the POSIX standard in the processing of the LANG environment variable and
\par               all environment variables starting with LC_.
\par 
\par        names  Traditional  and  POSIX  bc  have single letter names for functions, variables and arrays.  They have been
\par               extended to be multi-character names that start with a letter and may contain  letters,  numbers  and  the
\par               underscore character.
\par 
\par        Strings
\par               Strings are not allowed to contain NUL characters.  POSIX says all characters must be included in strings.
\par 
\par        last   POSIX bc does not have a last variable.  Some implementations of bc use the period (.) in a similar way.
\par 
\par        comparisons
\par               POSIX bc allows comparisons only in the if statement, the while statement, and the  second  expression  of
\par               the for statement.  Also, only one relational operation is allowed in each of those statements.
\par 
\par        if statement, else clause
\par               POSIX bc does not have an else clause.
\par 
\par        for statement
\par               POSIX bc requires all expressions to be present in the for statement.
\par 
\par        &&, ||, !
\par               POSIX bc does not have the logical operators.
\par 
\par        read function
\par               POSIX bc does not have a read function.
\par 
\par        print statement
\par               POSIX bc does not have a print statement .
\par 
\par        continue statement
\par               POSIX bc does not have a continue statement.
\par 
\par        return statement
\par               POSIX bc requires parentheses around the return expression.
\par 
\par        array parameters
\par               POSIX  bc  does  not (currently) support array parameters in full.  The POSIX grammar allows for arrays in
\par               function definitions, but does not provide a method to specify an array as an actual parameter.  (This  is
\par               most likely an oversight in the grammar.)  Traditional implementations of bc have only call by value array
\par               parameters.
\par 
\par        function format
\par               POSIX bc requires the opening brace on the same line as the define key word and the auto statement on  the
\par               next line.
\par 
\par        =+, =-, =*, =/, =%, =^
\par               POSIX  bc  does  not require these "old style" assignment operators to be defined.  This version may allow
\par               these "old style" assignments.  Use the limits statement to see if the installed  version  supports  them.
\par               If  it  does  support  the  "old style" assignment operators, the statement "a =- 1" will decrement a by 1
\par               instead of setting a to the value -1.
\par 
\par        spaces in numbers
\par               Other implementations of bc allow spaces in numbers.  For example, "x=1 3" would assign the  value  13  to
\par               the variable x.  The same statement would cause a syntax error in this version of bc.
\par 
\par        errors and execution
\par               This  implementation  varies from other implementations in terms of what code will be executed when syntax
\par               and other errors are found in the program.  If a syntax error is found in  a  function  definition,  error
\par               recovery  tries  to  find  the beginning of a statement and continue to parse the function.  Once a syntax
\par               error is found in the function, the function will not be callable and becomes undefined.  Syntax errors in
\par               the interactive execution code will invalidate the current execution block.  The execution block is termi-
\par               nated by an end of line that appears after a complete sequence of statements.  For example,
\par               a = 1
\par               b = 2
\par        has two execution blocks and
\par               \{ a = 1
\par                 b = 2 \}
\par        has one execution block.  Any runtime error will terminate the execution of the current execution block.  A  run-
\par        time warning will not terminate the current execution block.
\par 
\par        Interrupts
\par               During  an  interactive  session, the SIGINT signal (usually generated by the control-C character from the
\par               terminal) will cause execution of the current execution block to be interrupted.  It will display a  "run-
\par               time" error indicating which function was interrupted.  After all runtime structures have been cleaned up,
\par               a message will be printed to notify the user that bc is ready for  more  input.   All  previously  defined
\par               functions  remain  defined and the value of all non-auto variables are the value at the point of interrup-
\par               tion.  All auto variables and function parameters are removed during the clean up process.  During a  non-
\par               interactive session, the SIGINT signal will terminate the entire run of bc.
\par 
\par    LIMITS
\par        The  following are the limits currently in place for this bc processor.  Some of them may have been changed by an
\par        installation.  Use the limits statement to see the actual values.
\par 
\par        BC_BASE_MAX
\par               The maximum output base is currently set at 999.  The maximum input base is 16.
\par 
\par        BC_DIM_MAX
\par               This is currently an arbitrary limit of 65535 as distributed.  Your installation may be different.
\par 
\par        BC_SCALE_MAX
\par               The number of digits after the decimal point is limited to INT_MAX digits.  Also,  the  number  of  digits
\par               before the decimal point is limited to INT_MAX digits.
\par 
\par        BC_STRING_MAX
\par               The limit on the number of characters in a string is INT_MAX characters.
\par 
\par        exponent
\par               The value of the exponent in the raise operation (^) is limited to LONG_MAX.
\par 
\par        variable names
\par               The  current  limit  on the number of unique names is 32767 for each of simple variables, arrays and func-
\par               tions.
\par 
\par ENVIRONMENT VARIABLES
\par        The following environment variables are processed by bc:
\par 
\par        POSIXLY_CORRECT
\par               This is the same as the -s option.
\par 
\par        BC_ENV_ARGS
\par               This is another mechanism to get arguments to bc.  The format is the same as the command  line  arguments.
\par               These arguments are processed first, so any files listed in the environment arguments are processed before
\par               any command line argument files.  This allows the user to set up "standard" options and files to  be  pro-
\par               cessed at every invocation of bc.  The files in the environment variables would typically contain function
\par               definitions for functions the user wants defined every time bc is run.
\par 
\par        BC_LINE_LENGTH
\par               This should be an integer specifying the number of characters in an output line for numbers. This includes
\par               the  backslash  and  newline characters for long numbers.  As an extension, the value of zero disables the
\par               multi-line feature.  Any other value of this variable that is less than 3 sets the line length to 70.
\par 
\par DIAGNOSTICS
\par        If any file on the command line can not be opened, bc will report that the file  is  unavailable  and  terminate.
\par        Also, there are compile and run time diagnostics that should be self-explanatory.
\par 
\par BUGS
\par        Error recovery is not very good yet.
\par 
\par        Email bug reports to bug-bc@gnu.org.  Be sure to include the word \lquote \lquote bc\rquote \rquote  somewhere in the \lquote \lquote Subject:\rquote \rquote  field.
\par 
\par AUTHOR
\par        Philip A. Nelson
\par        philnelson@acm.org
\par 
\par ACKNOWLEDGEMENTS
\par        The author would like to thank Steve Sommars (Steve.Sommars@att.com) for his extensive help in testing the imple-
\par        mentation.  Many great suggestions were given.  This is a much better product due to his involvement.
\par 
\par GNU Project                       2006-06-11                             bc(1)
\par \plain \f2\fs20\cf6 ----------------------------------------------------------------------------------------------------\par}