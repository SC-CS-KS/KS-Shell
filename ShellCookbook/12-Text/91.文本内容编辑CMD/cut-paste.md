# cut/paste

## cut

cut用来剪下文本文件中的数据，文本文件可以是字段类型或字符类型。一般来说，选取信息通常是针对“行”来进行分析的，并不是整篇信息分析的。
-------------------------------------------------------------------------------------
语法格式
cut  [-bn] [file] 或 
cut [-c] [file]  或  
cut [-df] [file]
-------------------------------------------------------------------------------------
使用说明
cut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出。
如果不指定 File 参数，cut 命令将读取标准输入。
必须指定 -b、-c 或 -f 标志之一。
-------------------------------------------------------------------------------------
主要参数
-b ：以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志。
-c ：以字符为单位进行分割。
-d ：自定义分隔符，默认为制表符。
-f ：与-d一起使用，指定显示哪个区域。
-n ：取消分割多字节字符。仅和 -b 标志一起使用。
     如果字符的最后一个字节落在由 -b 标志的 List 参数指示的<br />范围之内，该字符将被写出；否则，该字符将被排除。
-------------------------------------------------------------------------------------
主要是接受三个定位方法：
字节（bytes），用选项-b
字符（characters），用选项-c
域（fields），用选项-f
-----------------------------------------------------------------------------
以“字节”定位
$ who
rocrocket :0           2009-01-08 11:07
rocrocket pts/0        2009-01-08 11:23 (:0.0)
rocrocket pts/1        2009-01-08 14:15 (:0.0)

如果我们想提取每一行的第3个字节，就这样：
$ who|cut -b 3
c
c
c

如果“字节”定位中，我想提取第3，第4、第5和第8个字节，怎么办?
-b支持形如3-5的写法，而且多个定位之间用逗号隔开就成了。看看例子吧：
$ who|cut -b 3-5,8
croe
croe
croe

但有一点要注意，cut命令如果使用了-b选项。
那么执行此命令时，cut会先把-b后面所有的定位进行从小到大排序，然后再提取。
这个例子就可以说明这个问题：
$ who|cut -b 8,3-5
croe
croe
croe

$ who|cut -b -3
roc
roc
roc

$ who|cut -b 3-
crocket :0           2009-01-08 11:07
crocket pts/0        2009-01-08 11:23 (:0.0)
crocket pts/1        2009-01-08 14:15 (:0.0)
想必你也看到了，-3表示从第一个字节到第三个字节，而3-表示从第三个字节到行尾。

如果你细心，你可以看到这两种情况下，都包括了第三个字节“c”。
如果我执行who|cut -b -3,3-，你觉得会如何呢？答案是输出整行，不会出现连续两个重叠的c的。
$ who|cut -b -3,3-
rocrocket :0           2009-01-08 11:07
rocrocket pts/0        2009-01-08 11:23 (:0.0)
rocrocket pts/1        2009-01-08 14:15 (:0.0)
-----------------------------------------------------------------------------
以字符为定位标志
$ who|cut -c 3-5,8
croe
croe
croe
看着怎么和-b没有什么区别啊？莫非-b和-c作用一样？
其实不然，看似相同，只是因为这个例子举的不好，who输出的都是单字节字符，所以用-b和-c没有区别。

如果你提取中文，区别就看出来了：
$ cat cut_ch.txt
星期一
星期二
星期三
星期四
$ cut -b 3 cut_ch.txt

$ cut -c 3 cut_ch.txt
一
二
三
四

用-c则会以字符为单位，输出正常；而-b只会傻傻的以字节（8位二进制位）来计算，输出就是乱码。

当遇到多字节字符时，可以使用-n选项，-n用于告诉cut不要将多字节字符拆开。
例子如下：
$ cat cut_ch.txt |cut -b 2
$ cat cut_ch.txt |cut -nb 2
$ cat cut_ch.txt |cut -nb 1,2,3
星
星
星
星
-----------------------------------------------------------------------------
按域剪切
$ cat /etc/passwd|head -n 5|cut -d : -f 1
root
bin
daemon
adm
lp

在设定-f时，也可以使用例如3-5或者4-类似的格式：
$ cat /etc/passwd|head -n 5|cut -d : -f 1,3-5
root:0:0:root
bin:1:1:bin
daemon:2:2:daemon
adm:3:4:adm
lp:4:7:lp

$ cat /etc/passwd|head -n 5|cut -d : -f 1,3-5,7
root:0:0:root:/bin/bash
bin:1:1:bin:/sbin/nologin
daemon:2:2:daemon:/sbin/nologin
adm:3:4:adm:/sbin/nologin
lp:4:7:lp:/sbin/nologin

$ cat /etc/passwd|head -n 5|cut -d : -f -2
root:x
bin:x
daemon:x
adm:x
lp:x

如果遇到空格和制表符时
有时候制表符确实很难辨认，有一个方法可以看出一段空格到底是由若干个空格组成的还是由一个制表符组成的。
$ cat tab_space.txt
this is tab finish.
this is several space      finish.
$ sed -n l tab_space.txt
this is tab\tfinish.$
this is several space      finish.$

如果是制表符（TAB），那么会显示为\t符号，如果是空格，就会原样显示。
注意：
上面sed -n后面的字符是L的小写字母哦，不要看错。

在cut -d中用什么符号来设定制表符或空格呢?其实cut的-d选项的默认间隔符就是制表符。
如果你设定一个空格为间隔符，那么就这样：
$ cat tab_space.txt |cut -d ' ' -f 1
this
this

注意，两个单引号之间可确实要有一个空格哦，不能偷懒。
而且只能在-d后面设置一个空格，可不许设置多个空格，因为cut只允许间隔符是一个字符。
$ cat tab_space.txt |cut -d '  ' -f 1
cut: the delimiter must be a single character
Try `cut --help' for more information.
-------------------------------------------------------------------------------------------------------
cut有哪些缺陷和不足？
猜出来了吧？对，就是在处理多空格时。
如果文件里面的某些域是由若干个空格来间隔的，那么用cut就有点麻烦了，因为cut只擅长处理“以一个字符间隔”的文本内容。
-------------------------------------------------------------------------------------------------------

## paste

paste
cut用来从文本文件或标准输出中抽取数据列或者域，然后再用paste可以将这些数据粘贴起来形成相关文件。
粘贴两个不同来源的数据时，首先需将其分类，并确保两个文件行数相同。

paste将按行将不同文件行信息放在一行。
缺省情况下，paste连接时，用空格或tab键分隔新行中不同文本，除非指定-d选项，它将成为域分隔符。
-------------------------------------------------------------------------------------------------------------------------------------
格式:
    paste -d -s -file1 file2
-------------------------------------------------------------------------------------------------------------------------------------
选项含义如下：
    -d 指定不同于空格或tab键的域分隔符。例如用@分隔域，使用- d @。
    -s 将每个文件合并成行而不是按行粘贴。
    - 使用标准输入。
-------------------------------------------------------------------------------------------------------------------------------------
实例：
#cat pas1
    ID897
    ID666
    ID982

#cat pas2
    P.Jones
    S.Round
    L.Clip
------------------------------------------------------
基本paste命令将pas1和pas2两文件粘贴成两列：
    # paste pas1 pas2
    ID897 P.Jones
    ID666 S.Round
    ID982 L.Clip
------------------------------------------------------
通过交换文件名即可指定哪一列先粘：
    #paste pas2 pas1
    P.Jones ID897
    S.Round ID666
    L.Clip ID982
------------------------------------------------------
要创建不同于空格或tab键的域分隔符，使用-d选项。
    #paste -d: pas2 pas1
    P.Jones:ID897
    S.Round:ID666
    L.Clip:ID982
------------------------------------------------------
要合并两行，而不是按行粘贴，可以使用-s选项。
    #paste -s pas1 pas2
    ID897 ID666 ID982
    P.Jones S.Round L.Clip
------------------------------------------------------
paste命令还有一个很有用的选项-
意即对每一个-，从标准输入中读一次数据。
使用@作域分隔符，以一个列格式显示目录列表。
    #ls | paste -d @ - -
    1@2
    book@book1
    file1@file2
    ls@-m
    who.out@w.out
