{\rtf1\fbidis\ansi\ansicpg0\uc1\deff0\deflang0\deflangfe0{\fonttbl{\f0\fnil \'cb\'ce\'cc\'e5;}{\f1\fnil \'ce\'a2\'c8\'ed\'d1\'c5\'ba\'da;}{\f2\fnil\fcharset134 \'cb\'ce\'cc\'e5;}{\f3\fnil Arial;}}{\colortbl;\red0\green0\blue255;\red0\green0\blue0;\red255\green255\blue255;}{\*\listtable{\list\listtemplateid68390225\listsimple1
{\listlevel\levelnfc23\leveljc0\li720\fi-360\jclisttab\tx720{\leveltext\'00;}{\levelnumbers;}\f3\fs24}
\listid600836762}
}
{\*\listoverridetable
{\listoverride\listid600836762\listoverridecount0\ls1}
}


\pard\fi0\li0\qc\ri0\sb0\sa0\itap0 \plain \f2\b\lang2052\fs24\cf2 24.nextfile
\par \pard\fi0\li0\ql\ri0\sb0\sa0\itap0 
\par \plain \f1\b\fs20 7.4.9 The\~\plain \f1\fs20 nextfile\~Statement
\par {\*\bkmkstart index_g_t_0040code_007bnextfile_007d_statement_1192}{\*\bkmkend index_g_t_0040code_007bnextfile_007d_statement_1192}\plain \f1\fs20\cf1 The\~nextfile\~statement is similar to the\~next\~statement. 
\par \plain \f1\fs20 However, instead of abandoning processing of the current record, the\~nextfile\~statement\plain \f1\fs20\cf1  instructs\~awk\~to stop processing the current data file.
\par 
\par \plain \f1\fs20 Upon execution of the\~nextfile\~statement,\~FILENAME\~is updated to the name of the next data file listed on the command line,\~FNR\~is reset to one, and processing starts over with the first rule in the program. If the\~nextfile\~statement causes the end of the input to be reached, then the code in any\~END\~rules is executed. An exception to this is when\~nextfile\~is invoked during execution of any statement in an\~END\~rule; In this case, it causes the program to stop immediately. See\~\plain \f1\ul\fs20\cf1 BEGIN/END\plain \f1\fs20 .
\par The\~nextfile\~statement is useful when there are many data files to process but it isn't necessary to process every record in every file. Without\~nextfile, in order to move on to the next data file, a program would have to continue scanning the unwanted records. The\~nextfile\~statement accomplishes this much more efficiently.
\par In\~gawk, execution of\~nextfile\~causes additional things to happen: any\~ENDFILE\~rules are executed except in the case as mentioned below,\~ARGIND\~is incremented, and anyBEGINFILE\~rules are executed. (ARGIND\~hasn't been introduced yet. See\~\plain \f1\ul\fs20\cf1 Built-in Variables\plain \f1\fs20 .)
\par With\~gawk,\~nextfile\~is useful inside a\~BEGINFILE\~rule to skip over a file that would otherwise cause\~gawk\~to exit with a fatal error. In this case,\~ENDFILE\~rules are not executed. See\~\plain \f1\ul\fs20\cf1 BEGINFILE/ENDFILE\plain \f1\fs20 .
\par While one might think that \lquote close(FILENAME)\rquote  would accomplish the same as\~nextfile, this isn't true.\~close()\~is reserved for closing files, pipes, and coprocesses that are opened with redirections. It is not related to the main processing that\~awk\~does with the files listed in\~ARGV.
\par \pard\li720\fi-360\jclisttab\tx720\ql\ri0\sb0\sa0\itap0 {\listtext\pard\plain\f3\fs24 \tab}\ls1\ilvl0 \plain \f1\b\fs20 NOTE:\plain \f1\fs20 \~For many years,\~nextfile\~was a\~gawk\~extension. As of September, 2012, it was accepted for inclusion into the POSIX standard. See\~\plain \f1\ul\fs20\cf1 the Austin Group website\plain \f1\fs20 .
\par \plain\pard\fi0\li0\ql\ri0\sb0\sa0\itap0 {\*\bkmkstart index_functions_002c_user_002ddefined_002c__0040code_007bnext_007d_002f_0040code_007bnextfile_007d_statements_and_1193}{\*\bkmkend index_functions_002c_user_002ddefined_002c__0040code_007bnext_007d_002f_0040code_007bnextfile_007d_statements_and_1193}\plain \f1\fs20 The current version of the Brian Kernighan's\~awk\~(see\~\plain \f1\ul\fs20\cf1 Other Versions\plain \f1\fs20 ) also supports\~nextfile. However, it doesn't allow the\~nextfile\~statement inside function bodies (see\plain \f1\ul\fs20\cf1 User-defined\plain \f1\fs20 ).\~gawk\~does; a\~nextfile\~inside a function body reads the next record and starts processing it with the first rule in the program, just as any other\~nextfilestatement.\par}