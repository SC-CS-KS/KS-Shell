{\rtf1\fbidis\ansi\ansicpg0\uc1\deff0\deflang0\deflangfe0{\fonttbl{\f0\fnil \'cb\'ce\'cc\'e5;}{\f1\fnil \'ce\'a2\'c8\'ed\'d1\'c5\'ba\'da;}{\f2\fnil\fcharset134 \'cb\'ce\'cc\'e5;}{\f3\fnil Arial;}}{\colortbl;\red0\green0\blue255;\red0\green0\blue0;\red255\green255\blue255;}{\*\listtable{\list\listtemplateid264014738\listsimple1
{\listlevel\levelnfc0\leveljc0\li720\fi-360\jclisttab\tx720\levelstartat1{\leveltext\'02\'00.;}{\levelnumbers\'01;}\f3\fs24}
\listid2067695070}
{\list\listtemplateid1346100061\listsimple1
{\listlevel\levelnfc0\leveljc0\li720\fi-360\jclisttab\tx720\levelstartat1{\leveltext\'02\'00.;}{\levelnumbers\'01;}\f3\fs24}
\listid959955158}
{\list\listtemplateid406412848\listsimple1
{\listlevel\levelnfc0\leveljc0\li720\fi-360\jclisttab\tx720\levelstartat1{\leveltext\'02\'00.;}{\levelnumbers\'01;}\f3\fs24}
\listid121117429}
{\list\listtemplateid363535563\listsimple1
{\listlevel\levelnfc0\leveljc0\li720\fi-360\jclisttab\tx720\levelstartat1{\leveltext\'02\'00.;}{\levelnumbers\'01;}\f3\fs24}
\listid1838202875}
}
{\*\listoverridetable
{\listoverride\listid2067695070\listoverridecount0\ls1}
{\listoverride\listid959955158\listoverridecount0\ls2}
{\listoverride\listid121117429\listoverridecount0\ls3}
{\listoverride\listid1838202875\listoverridecount0\ls4}
}


\pard\fi0\li0\qc\ri0\sb0\sa0\itap0 \plain \f2\b\lang2052\fs24\cf2 igawk script content
\par \pard\fi0\li0\ql\ri0\sb0\sa0\itap0 
\par \plain \f1\fs20 #! /bin/sh
\par \plain \f1\fs20\cf1 # igawk --- like gawk but do @include processing
\par \plain \f1\fs20 #
\par # Arnold Robbins, arnold@gnu.org, Public Domain
\par # July 1993
\par 
\par if [ "$1" = debug ]
\par then
\par     set -x
\par     shift
\par fi
\par 
\par # A literal newline, so that program text is formmatted correctly
\par n='
\par '
\par 
\par # Initialize variables to empty
\par program=
\par opts=
\par 
\par while [ $# -ne 0 ] # loop over arguments
\par do
\par     case $1 in
\par     --)     shift; break;;
\par 
\par     -W)     shift
\par             # The $\{x?'message here'\} construct prints a
\par             # diagnostic if $x is the null string
\par             set -- -W"$\{@?'missing operand'\}"
\par             continue;;
\par 
\par     -[vF])  opts="$opts $1 '$\{2?'missing operand'\}'"
\par             shift;;
\par 
\par     -[vF]*) opts="$opts '$1'" ;;
\par 
\par     -f)     program="$program$n@include $\{2?'missing operand'\}"
\par             shift;;
\par 
\par     -f*)    f=`expr "$1" : '-f\\(.*\\)'`
\par             program="$program$n@include $f";;
\par 
\par     -[W-]file=*)
\par             f=`expr "$1" : '-.file=\\(.*\\)'`
\par             program="$program$n@include $f";;
\par 
\par     -[W-]file)
\par             program="$program$n@include $\{2?'missing operand'\}"
\par             shift;;
\par 
\par     -[W-]source=*)
\par             t=`expr "$1" : '-.source=\\(.*\\)'`
\par             program="$program$n$t";;
\par 
\par     -[W-]source)
\par             program="$program$n$\{2?'missing operand'\}"
\par             shift;;
\par 
\par     -[W-]version)
\par             echo igawk: version 2.0 1>&2
\par             gawk --version
\par             exit 0 ;;
\par 
\par     -[W-]*) opts="$opts '$1'" ;;
\par 
\par     *)      break;;
\par     esac
\par     shift
\par done
\par 
\par if [ -z "$program" ]
\par then
\par      program=$\{1?'missing program'\}
\par      shift
\par fi
\par 
\par # At this point, `program' has the program.
\par expand_prog='
\par 
\par function pathto(file,    i, t, junk)
\par \{
\par     if (index(file, "/") != 0)
\par         return file
\par 
\par     for (i = 1; i <= ndirs; i++) \{
\par         t = (pathlist[i] "/" file)
\par         if ((getline junk < t) > 0) \{
\par             # found it
\par             close(t)
\par             return t
\par         \}
\par     \}
\par     return ""
\par \}
\par BEGIN \{
\par     path = ENVIRON["AWKPATH"]
\par     ndirs = split(path, pathlist, ":")
\par     for (i = 1; i <= ndirs; i++) \{
\par         if (pathlist[i] == "")
\par             pathlist[i] = "."
\par     \}
\par     stackptr = 0
\par     input[stackptr] = ARGV[1] # ARGV[1] is first file
\par 
\par     for (; stackptr >= 0; stackptr--) \{
\par         while ((getline < input[stackptr]) > 0) \{
\par             if (tolower($1) != "@include") \{
\par                 print
\par                 continue
\par             \}
\par             fpath = pathto($2)
\par             if (fpath == "") \{
\par                 printf("igawk:%s:%d: cannot find %s\\n",
\par                     input[stackptr], FNR, $2) > "/dev/stderr"
\par                 continue
\par             \}
\par             if (! (fpath in processed)) \{
\par                 processed[fpath] = input[stackptr]
\par                 input[++stackptr] = fpath  # push onto stack
\par             \} else
\par                 print $2, "included in", input[stackptr],
\par                     "already included in",
\par                     processed[fpath] > "/dev/stderr"
\par         \}
\par         close(input[stackptr])
\par     \}
\par \}'  # close quote ends `expand_prog' variable
\par 
\par processed_program=\plain \f1\fs20\cf1 `gawk -- "$expand_prog" /dev/stdin <<EOF
\par $program
\par \plain \f1\fs20 EOF
\par `
\par \plain \f1\fs20\cf1 eval gawk $opts -- '"$processed_program"' '"$@"'\par}