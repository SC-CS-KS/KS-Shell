# 05.变量替换

一般变量替换
Shell之所以强大，其中的一个因素是它可以在命令行中对变量作替换(substitution)处理。
在命令行中使用者可以使用$符号加上变量名称(除了在用=号定义变量名称之外)，将变量值给替换出来，然后再重新组建命令行。

代码:   
      # A=ls   
      # B=la   
      # C=/tmp   
      # $A -$B $C   
必需强调的是，我们所提的变量替换，只发生在command line上面。

仔细分析最后那行command  line，不难发现在被执行之前(在输入CR字符之前)，
$符号会对每一个变量作替换处理(将变量值替换出来再重组命令行)。

最后会得出如下命令行：   
ls -la /tmp   

若从技术细节来看，shell	会依据  IFS(Internal  Field  Seperator)	将 command  line所输入的文字给拆解为"字段"(word)。
然后再针对特殊字符(meta)先作处理，最后再重组整行  command line	。
$就是  command line中最经典的meta之一了，就是作变量替换的﹗
--------------------------------------------------------------------------------------------------------------------------------
利用 shell对变量的替换处理能力，在设定变量时就更为灵活了：
A=B   
B=$A   
这样，B 的变量值就可继承A变量"当时"的变量值了。

不过，不要以"数学罗辑"来套用变量的设定，比方说：
A=B   
B=C   
这样并不会让 A的变量值变成 C。

再如：
A=B   
B=$A   
A=C   
同样也不会让B的值换成C。上面是单纯定义了两个不同名称的变量：A 与  B ，它们的值分别是 C 与 B。
若变量被重复定义的话，则原有旧值将被新值所取代。(这不正是"可变的量"吗？)

当在设定变量的时侯，请记着这点：
*用一个名称储存一个数值，仅此而已。
---------------------------------------------------------------------------------
也可利用命令行的变量替换能力来"扩充"(append)变量值：
A=B:C:D   
A=$A:E   
这样，第一行设定A的值为"B:C:D"，然后，第二行再将值扩充为"A:B:C:E"。

上面的扩充范例，使用区隔符号( : )来达到扩充目的，要是没有区隔符号的话，如下是有问题的：
A=BCD   
A=$AE   

因为第二次是将A的值继承$AE的替换结果，而非$A再加E。
要解决此问题，可用更严谨的替换处理：
A=BCD   
A=${A}E   
上例中，我们使用{}将变量名称的范围给明确定义出来，如此一来，我们就可以将A的变量值从BCD给扩充为BCDE。

(提示：关于 ${name}事实上还可做到更多的变量处理能力，这些均属于比较进阶的变量处理。
------------------------------------------------------------------------------------
