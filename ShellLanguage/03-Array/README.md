# 03.Shell Array

## 01.数组 定义

### 1.Linux shell 常规数组

1.Linux shell 常规数组
1.1 常规数组的声明：
Linux shell 的常规数组使用整数值作为索引值

1.1.1 使用一个元素列表声明并初始化一个常规数组
array_var0=(a0 a1 a2 a3 a4 a5);

1.1.2 使用数组下标与元素值声明并初始化一个常规数组
array_var1[1]="test1";
array_var1[2]="test2";
array_var1[3]="test3---";?MOD
#array_var1[4]="test4";
array_var1[5]="test5";
array_var1[6]="test6";
array_var1[7]="test7";
------------------------------------------------------------------------------------------------

### 2.Linux Shell 关联数组

2. Linux Shell 关联数组  

所谓关联数组就是使用字符串作为索引值对数组进行访问的数组

2.1 关联数组的声明：
declare -A arrayName;
（必须要这么写，先声明）

2.2 关联数组初始化与元素添加：
2.2.1 使用 "[index]=value" 列表的方式对关联数组添加元素：
declare -A assArray1;
assArray1=([index1]=cat [index2]=dogs [index98]=fish);

2.2.2 使用 "arrayName[index]=value" 的方式对关联数组进行添加元素：
declare -A assArray2;
assArray2[pear]=100;
assArray2[apple]=3000;
assArray2[orange]=70000;

注意 ：
bash 4.0版本以上才支持关联数组
------------------------------------------------------------------------------------------------

## 02.数组 操作

### 1.获取长度

长度：
$ echo ${#a[@]}
5
用${#数组名[@或*]} 可以得到数组长度
----------------------------------------------------------------------

### 2.获取元素

读取：
$ echo ${a[2]} 
3

$ echo ${a[*]}   
1 2 3 4 5

用${数组名[下标]}对数组元素读取。
下标是从0开始 ，下标如果是：*或者@ 得到整个数组内容。
----------------------------------------------------------------------

### 3.元素赋值

赋值:
$ a[1]=100

$ echo ${a[*]} 
1 100 3 4 5

直接通过 数组名[下标] 就可以对其进行引用赋值，如果下标不存在，自动添加新一个数组元素。
$ a[5]=100
$ echo ${a[*]} 
1 2 3 4 5 100

$ a[7]=10
$ echo ${a[*]}  
1 2 3 4 5 100 10                            #10的数组索引是7，而不是6
$ echo ${a[7]}  
10
$ echo ${a[6]}  
----------------------------------------------------------------------

### 4.删除

删除:
$ a=(1 2 3 4 5)
$ unset a
$ echo ${a[*]}

$ a=(1 2 3 4 5)
$ unset a[1]   
$ echo ${a[*]} 
1 3 4 5
$ echo ${#a[*]}
4

直接通过：unset 数组[下标] 可以清除相应的元素，不带下标，清除整个数据。
----------------------------------------------------------------------

### 5.分片

分片:
$ a=(1 2 3 4 5)
$ echo ${a[@]:0:3}
1 2 3
$ echo ${a[@]:1:4}
2 3 4 5

$ c=(${a[@]:1:4})
$ echo ${#c[@]}
4
$ echo ${c[*]} 
2 3 4 5

直接通过 ${数组名[@或*]:起始位置:长度} 切片原先数组，返回是字符串。
中间用“空格”分开，因此如果加上”()”，将得到切片数组，上面例子：c 就是一个新数据。
---------------------------------------------------------------------------------------------------

### 6.替换

替换:
$ a=(1 2 3 4 5)    
$ echo ${a[@]/3/100}
1 2 100 4 5

$ echo ${a[@]}
1 2 3 4 5

${数组名[@或*]/查找字符/替换字符} 
该操作不会改变原先数组内容，如果需要修改，可以看上面例子，重新定义数据。

$ a=(${a[@]/3/100}) 
$ echo ${a[@]}     
1 2 100 4 5
--------------------------------------------------------------------------------------------------

## 05.数组 遍历

### 01.根据长度遍历

根据长度遍历
a_len=${#arr[@]}
for (( i=0; i<a_len; i++))
do
   echo   ${arr[i]}
done
--------------------------------------------------------------------------------------------

### 02.根据Value遍历

根据值遍历
filename=(`ls`)
for var in ${filename[@]}
do
   echo $var
done
--------------------------------------------------------------------------------------------

### 03.根据Key遍历

${!arr[@]}
用于返回数组array的所有下标
arr=(h0 h1 h2 h3)
for i in ${!arr[@]}; do echo $i; done
>>> 0 1 2 3
arr[10]=h10
for i in ${!arr[@]}; do echo $i; done
>>> 0 1 2 3 10

初始化数组arr时，数组下标是从0开始递增的，所以这里直接对arr[10]进行赋值，以空缺中间的下标，打印其下标如上。
--------------------------------------------------------------------------------------------

## 10.数组 传参

测试脚本
#!/bin/bash
echo $1
echo $2
echo $3
echo $4
echo $5
echo $6
echo $7
echo $8
echo $9
echo $10
 
构造数组
atest=("a" "bb cc" "dd ee ff" "gg hh ii jj")
------------------------------------------------------------------------------------------------------------------ 

### 函数传参

作为函数参数
实例： 反转数组
function reverse_arr()
{
  arr_tmp=($@)
  for ((i = 0;i <${#arr_tmp[@]};i++))
  do
    ARR_REVERSED[arr_tmp[$i]]=$i
  done
}
------------------------------------------------------------------------------------------------------------------

### 脚本传参

作为脚本参数
atest为数组。此时若把这个数组的内容作为参数调用另一个shell脚本时，写法很关键。
第一种写法：./test.sh ${atest[@]}
执行结果：
a
bb
cc
dd
ee
ff
gg
hh
ii
a0
此时传递的参数为a bb cc dd ee ff gg hh ii jj。
把数组的内容组成了一个字符串，已经破坏了原来数组的结构。

第二种写法：./test.sh “${atest[@]}”
执行结果：
a
bb cc
dd ee ff
gg hh ii jj
a0
把数组用双引号括起来，此时传递到test.sh中的参数仍然为数组的原来结构。
------------------------------------------------------------------------------------------------------------------

## 20.数组 实例

01.从“标准输入”读入n次字符串，每次输入的字符串保存在数组array里
#!/bin/bash
i=0
n=5
while [ "$i" -lt $n ] ; do
  echo "Please input strings ... `expr $i + 1`"
  read array[$i]
  b=${array[$i]}
  echo "$b"
  i=`expr $i + 1`
done
-----------------------------------------------------------------------------------------------------
02.将字符串里的字母逐个放入数组，并输出到“标准输出”
#!/bin/bash
chars='abcdefghijklmnopqrstuvwxyz'
for (( i=0; i<26; i++ )) ; do
    array[$i]=${chars:$i:1}
    echo ${array[$i]}
done
这里有趣的地方是 ${chars:$i:1}，表示从chars字符串的 $i 位置开始，获取 1 个字符。
如果将 1 改为 3 ，就获取 3 个字符啦～ 结果是：
abc
bcd
...
vxy
xyz
yz     //没有足够字符串获取了
z      //没有足够字符串获取了
-----------------------------------------------------------------------------------------------------
03.将数组应用到shell环境变量
# SEASON=("Srping" "Summer" "Autumn" "Winter")
当你发现赋值错了，也可以立刻从新赋值纠正，如上面的 Spring 被写成 Srping。
重新赋值：（原来的值被重写）
# SEASON=("Spring" "Summer" "Autumn" "Winter")

查看一下环境变量：
# set | grep SEASON
SEASON=([0]="Spring" [1]="Summer" [2]="Autumn" [3]="Winter")

使用tr命令将文件中的回车转换成空格：
# cat /etc/shells | tr "\n" " " > /tmp/tmp.file

将文件中内容给数组赋值：(碰到第一个回车符之前的内容)
# read -a SHELLS < /tmp/tmp.file

查看数组赋值情况：
# set | grep "SHELLS"
SHELLS=([0]="/bin/sh" [1]="/bin/bash" [2]="/sbin/nologin" [3]="/bin/tcsh" [4]="/bin/csh" [5]="/bin/ksh")
-----------------------------------------------------------------------------------------------------
