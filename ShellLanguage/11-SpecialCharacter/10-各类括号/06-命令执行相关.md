# 06.命令执行相关

## () 和 {}

一串的命令执行()和{}
()和{}都是对一串的命令进行执行，但有所区别：

01.()只是对一串命令重新开一个子shell进行执行
02.{}对一串命令在当前shell执行

03.()和{}都是把一串的命令放在括号里面，并且命令之间用;号隔开
04.()最后一个命令可以不用分号
05.{}最后一个命令要用分号

06.{}的第一个命令和左括号之间必须要有一个空格
07.()里的各命令不必和括号有空格
08.()和{}中括号里面的某个命令的重定向只影响该命令，但括号外的重定向则影响到括号里的所有命令
-------------------------------------------------------------------------------------------------------------------------------------

实例：
# var=test
# (var=notest; echo $var)                                        #变量var值为notest，此是在子shell中有效
notest
# echo $var                                                      #父shell中值仍为test
test
------------------------------------------------------------------------------------
# { var=notest; echo $var;}                                      #注意左括号和var之间要有一个空格
notest
$ echo $var                                                      #父shell中的var变量的值变为了notest
notest
------------------------------------------------------------------------------------
$ { var1=test1;var2=test2;echo $var1 > a;echo $var2;}            #输出test1被重定向到文件a中，而test2输出则仍输出到标准输出中。
test2                                                        
$ cat a
test1
------------------------------------------------------------------------------------
$ { var1=test1;var2=test2;echo $var1;echo $var2;} >a            #括号内命令的标准输出全部被重定向到文件a中
$ cat a
test1
test2
-------------------------------------------------------------------------------------------------------------------------------------

# $(cmd) `cmd`

命令替换$(cmd)和符号`cmd`
# ls
a b c
# echo $(ls)
a b c
# echo `ls`
a b c
分析一下命令echo $(ls)，以便理解所谓命令替换是什么意思：
shell扫描一遍命令行，发现了$(cmd)结构，便将$(cmd)中的cmd执行一次，得到其标准输出。
再将此输出放到原来命令echo $(ls)中的$(ls)位置，即替换了$(ls),再执行echo命令。

要注意的是：
$(cmd)中的命令的错误输出是不会被替换的，替换的只是标准输出。
------------------------------------------------------------------------------------

