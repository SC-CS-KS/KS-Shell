# 01.Shell 元字符

字符
说明
IFS
由 <space> 或 <tab> 或 <enter> 三者之一组成(我们常用 space )。
CR
由 <enter> 产生。
=
设定变量。
$
作变量或运算替换(请不要与 shell prompt 搞混了)。
>
重导向 stdout。 *
<
重导向 stdin。 *
|
命令管线。 *
&
重导向 file descriptor ，或将命令置于背境执行。 *
( )
将其内的命令置于 nested subshell 执行，或用于运算或命令替换。 *
{ }
将其内的命令置于 non-named function 中执行，或用在变量替换的界定范围。
;
在前一个命令结束时，而忽略其返回值，继续执行下一个命令。 *
&&
在前一个命令结束时，若返回值为 true，继续执行下一个命令。 *
||
在前一个命令结束时，若返回值为 false，继续执行下一个命令。 *
!
执行 history 列表中的命令。*

可以看到shell 元字符，基本是作用在命令上面，用作多命令分割（或者参数分割）。
因此看到与通配符有相同的字符，但是实际上作用范围不同。所以不会出现混淆。
 
以下是man bash 得到的英文解析：
metacharacter
              A character that, when unquoted, separates words.  One of the following:
              |  & ; ( ) < > space tab
control operator
              A token that performs a control function.  It is one of the following symbols:
              || & && ; ;; ( ) | <newline>
-----------------------------------------------------------------------------------------------------------------------
# 
表示注释                     #注释
在引号中间和\#等表示#本身
echo ${PATH#*:}              # 参数替换，不是一个注释
echo $(( 2#101011 ))         # 数制转换，不是一个注释
----------------------------------------------------------------------
; 分隔
命令分隔，在一行中写多个命令  echo "aa" ; echo "bb"
在条件中的if和then如果放在同一行，也用;分隔
----------------------------------------------------------------------
;;      case条件的结束
----------------------------------------------------------------------
. 命令相当于source命令
·	命令：source
·	文件名的前缀，隐藏文件
·	目录：.当前目录，..父目录
·	正则表达式：匹配任意单个字符
----------------------------------------------------------------------
""     部分引用 支持通配符扩展
----------------------------------------------------------------------
''     全引用，不进行通配符扩展
----------------------------------------------------------------------
\      转义
----------------------------------------------------------------------
/      目录分隔符
----------------------------------------------------------------------
,      多个命令都被执行，但返回最后一个
----------------------------------------------------------------------
`      后置引用
----------------------------------------------------------------------
: 
·	空操作
·	死循环 while :
·	在if/then中表示什么都不做，引出分支
·	设置默认参数：   : ${username=`whoami`}
·	变量替换：    : ${HOSTNAME?} ${USER?} ${MAIL?}
·	在和 > (重定向操作符)结合使用时,把一个文件截断到0 长度,没有修改它的权限；如果文件在之前并不存在，那么就创建它。如:     
·	  : > data.xxx #文件"data.xxx"现在被清空了. 与 cat /dev/null >data.xxx 的作用相同 然而,这不会产生一个新的进程,因为":"是一个内建命令.
·	在和>>重定向操作符结合使用时，将不会对想要附加的文件产生任何影响。
·	如果文件不存在，将创建。
----------------------------------------------------------------------
*       匹配0个或多个字符；数学乘法；**幂运算
----------------------------------------------------------------------
?       匹配任意一个字符；但在((a>b?a:b))表示c语言中的三目运算
----------------------------------------------------------------------
$ 
        取变量的值 echo $PATH
        正则表达式中表示行的结尾
        ${} 参数替换 ${PAHT}
        $* 所有参数
        $# 参数个数
        $$ 进程的ID
        $? 进程的返回状态
----------------------------------------------------------------------
( )
命令组，在一个子Shell中运行   (a=3;echo $a) 其中定义的变量在后面不可用
数组初始化： array=(a,b,c)
----------------------------------------------------------------------
{ }     代码块，即一个匿名函数，但其中定义的变量在后面依然可用
----------------------------------------------------------------------
{ } \;   用在find的-exec中 $find -name *.txt -exec cat {} \;
----------------------------------------------------------------------
[ ]
测试 [-z $1]
数组元素 a[1]='test'
[[]]表示测试 使用[[ ... ]]条件判断结构, 而不是[ ... ], 能够防止脚本中的许多逻辑错误。
比如, &&, ||, <, 和> 操作符能够正常存在于[[ ]]条件判断结构中, 但是如果出现在[ ]结构中的话, 会报错.
(( ))数学运算
在正则表达式中表示范围 [a-z]
----------------------------------------------------------------------
< <<  >  重定向和进程替换  ls -al > a.txt
----------------------------------------------------------------------
>  <     还用在ASCII比较 if [[ "$veg1" < "$veg2" ]]
----------------------------------------------------------------------
\<,\>    正则表达式中的单词边界
         如:bash$grep '\<the\>' textfile
----------------------------------------------------------------------
|       管道
---------------------------------------------------------------------- 
>|      强制重定向(即使设置了noclobber 选项--就是-C 选项)。这将强制的覆盖一个现存文件。
----------------------------------------------------------------------
||      逻辑或操作 用在两个命令之间的时候，表示在前一个命令结束时，若返回值为 false，继续执行下一个命令
&&      逻辑与     用在两个命令之间的时候，表示在前一个命令结束时，若返回值为 true，继续执行下一个命令
----------------------------------------------------------------------
&       后台运行
----------------------------------------------------------------------
-
参数选项
减号
重定向stdin和stdout：cd /source/directory && tar cf - . ) | (cd /dest/directory && tar xpvf -)
先前的工作目录 cd -
注：使用-开头的文件名和变量名可能会出现一些问题
----------------------------------------------------------------------
+       一个命令或者过滤器的选项标记
----------------------------------------------------------------------
~       home目录
----------------------------------------------------------------------
~+     当前工作目录
----------------------------------------------------------------------
~-     先前工作目录
----------------------------------------------------------------------
^      正则表达式中表示行首
----------------------------------------------------------------------
 
