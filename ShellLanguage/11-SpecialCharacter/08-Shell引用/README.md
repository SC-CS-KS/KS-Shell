# 08.Shell 引用

在shell中有两类字符，一类是普通字符(literal)，在shell中没有任何特殊意义；另一类是所谓“元字符”(meta)，在shell中有特殊的含义或用法。

当我们需要去掉元字符的特殊含义而恢复其字面意义时就必须使用“引用”(quoting)。
通常有三种引用方式，
他们是转义(Escape，使用反斜杠字符\，即backslash),
强引用(使用单引号',即single quote)
弱引用(使用双引号", 即double quote)。

转义：是用反斜杠放在需要转义的一个字符前，表示那个字符要看作一个普通字符。
强引用：是用单引号把要转义的字符串括起来，其中任何字符都看作普通字符，除了单引号自身。
             所以你无法在两个单引号之间包含单引号，用\转义也不行。
弱引用：是用双引号把要转义的字符串括起来，除了双引号"本身，其中的大部分字符都看作普通字符。例外的还有\,$,`三个特殊字符。
             因为\在""中是特殊字符，所以你可以在其中包含"本身，前提是必须转义。
             $是特殊字符，这表示你可以使用变量$var/${var}及其它，在ksh/bash中可以引用算术表达式的结果$((...))，还可以作命令替换$()。
             由于`是特殊字符在bsh中也可以作命令替换，但只能使用`...`的语法(这个在ksh/bash中也可以使用)。

## 01.单引号

单引号
    任何在单引号内的字符的引用就等同于在其前面加上\的引用。如果你要引用的字串中有一个单引号，你就不能用单引号去引用。
    如：
    echo 'It's Friday'
    会出现下为的提示：
    >_光标在闪烁它在等待输入。
    >_标示是shell的第二提示符，它表明你有一个多行的命令在输入，现在还没有输完。引号必须是成对出现，它影响它中间的所有字符。
    上例你改为如下：
    echo It\'s Friday

## 02.双引号

双引号
    单引号有时会剥夺shell的好多特殊方便的地方。下面的例子中有许多特殊的字符为了输出字符本身你必须使用引用。
    echo '$USER owes ; [ as of (｀date +%m/%d｀) ]'
    你很容易想到用单引号去实现，下面可能是你不想要的结果：
    $USER owes ; [ as of (｀date +%m/%d｀) ]

    单引号会阻止变量替换，于是＄USER不会被它的值替换。还阻止了命令替换不能显示日期。双引号可以解决这个问题。
    上例把单引号换成双引号的结果会是：
    #echo "$USER owes ; [ as of ('date +%m/%d') ]"
    root owes ; [ as of (12/21) ]

## 03.反斜杠

今天我们单独研究一下反斜线\。
这是一个有魔力的字符，它可以用来对任何字符转义，也包括它自己。
但是在不同的shell实现中它的表现似乎不尽相同，有时结果让你会大吃一惊。
------------------------------------------------------------------------------------------------------------
先来看一个简单的例子，假定我们要输出单独一个\，先用bash：
$ echo \\
\
$ echo "\\"
\
$ echo '\'
\
第一个echo，因为\是元字符，所以必须对它进行转义，所以我们必须用两个\。
第二个echo，因为""是弱引用，其中的\仍然是特殊字符，所以同样必须转义。
第三个echo，''是强引用，\在单引号之中是普通字符，这样就不用再转义了，所以只用一个\。
------------------------------------------------------------------------------------------------------------
OK，假如我们要输出连续两个\，怎样呢？看一下：
$ echo \\\\
\\
$ echo "\\\\"
\\
$ echo '\\'
\\
嗯，好像没有什么奇怪的事发生，我们简单地使用双倍的\就搞定了。
------------------------------------------------------------------------------------------------------------
那再让我们用ksh来试试来做同样的事：
$ echo \\
\
$ echo "\\"
\
$ echo '\'
\

这个容易，简单的重复罢了。再来两个\：
$ echo \\\\
\
$ echo "\\\\"
\
$ echo '\\'
\
等等，怎么搞的？为什么只输出了一个\?

再加一个\会如何？
$ echo \\\\\
>
\
$ echo \\\\\\
\\
$ echo "\\\\\"
>
\
$ echo "\\\\\\"
\\
$ echo '\\'
\\
第一个echo没有立即执行，ksh给出了一个>(PS2提示符)，等待我们继续输入，回车后echo仍然只输出了一个\。
第二个echo后面是六个\，呼～，这回终于输出两个\了。
双引号的情形也是类似，我们仍然需要六个\。
第五个echo，好在单引号的结果还算不错，只要两个\就行了。

你可以继续做这个试验，最后会发现在不用单引号时，
我们需要2个或4个\输出1个\，需要6个或8个\输出2个\,10个或12个\来输出3个\，......真是又臭又长！
输出        命令行需要\的个数
\        2/4
\\       6/8
\\\      10/12
\\\\     14/16
\\\\\   18/20
...       ...
n个\    4n-2/4n

厌倦了吗？其实ksh下除了用'，还有其它方法剪断这“懒婆娘的裹脚布”。
窍门就在于echo命令的-E选项：
$ echo -E \\
\
$ echo -E \\\\
\\
$ echo -E \\\\\\
\\\
很好！这样与bash下的情况就一样了。
-------------------------------------------------------------------------------------------------------------------------
-E选项是不是很神奇呀！为什么呢？
原来bash和ksh的echo命令缺省的表现是不同的。
我们知道echo命令可以接受一些转义字符序列来表示特殊的字符，如\n表示换行，\a表示蜂鸣，\t表示水平制表符等等。
显然在解释转义序列时\是一个特殊字符。

在bash下echo缺省的设置是不解释这些转义序列，为了告诉它解释转义序列我们必须使用-e选项。
而在ksh下echo的缺省设置就会解释这些转义序列，我们可以用-E选项让它不解释转义序列。

所以ksh下在不使用-E选项时实际上会发生两次转义的过程，第一次发生在ksh处理命令行时，第二次发生在echo命令处理它的参数时。
让我们看下面这个简单的例子：
$ set -x
$ echo \\\\
+ echo \\
\

先用set -x让ksh显示命令行处理的结果，我们看到，第一个\转义第二个\，去掉它的特殊含义，同样第三个\转义第四个\去掉它的特殊含义，
这样命令行处理完毕以后传给echo的参数是\\。
echo然后将\\解释成了\并输出。于是我们只得到一个\。

bsh中echo的缺省表现与ksh中类似，解释转义序列，不过可惜无法关掉这一功能。
我们还是可以使用外部命令来不解释转义序列原样输出，例如在Linux下可以用
/bin/echo -E(可以省略)来做。

下来看一个从本论坛来的例子，提问者的意图是将dos格式的路径中的\变成\\，但他的shell好像工作得不好：
$echo C:\\tmp | sed 's/\\/&\\/'
C:        mp

$echo 'C:\abc'|sed 's/\\/\\\\/'
C:bc

在看过上面我们对引用和echo的讨论之后，您能为他解释一下其中的原因吗？
对了，这两条命令的语法都没有错，不过提问者使用的shell八成是ksh(也可能是bsh,但可能性较小)，问题是出在echo上。
在ksh下echo默认解释转义序列，所以命令行的
echo c:\\tmp部分先做命令行解释，\\变成\，于是执行：
echo 'c:\tmp'

而\t是一个转义序列，它代表水平制表符，所以echo最后输出
c:<水平制表符>mp
同样
echo 'c:\abc'
会输出
c:<蜂鸣字符>bc
你应该会听到你的终端发出“嘟”的一声。
这下清楚了吧？echo的输出就是错误的，后面sed的替换根本就没有匹配执行，当然不会有正确的结果。
上面两个命令在bash下是正确的，为什么？
那在ksh下怎样修改让它正确工作呢？如果是bsh呢？改法可能不止一种，不过这个还是留给亲爱的读者您作为一个练习好了。
-------------------------------------------------------------------------------------------------------------------------------------
下面列出许多shell的特殊字符也叫元字符:
    * ? [ ] ' ' \ $ ; & ( ) | ^ 回车换行 空格 制表符
    执行#echo Hello; world 会得到下面错误提示：
    Hello
    sh: world: Command not found
    
上例中分号的作用就是告诉shell这是命令的结尾，接下来是一个新命令，可以把多个命令写到一行中去执行。
因为world不是命令所以会有上面的错误提示。

解决这个问题的方法就是加上\，这个\去除它的特殊含义，使你去显示这个字符本身。
-------------------------------------------------------------------------------------------------------------------------------------

## 04.反引号

命令替换(command substitution)，是指在命令行获取另一个命令的标准输出，
换句话说，它是将一个命令的标准输出代换到另一个命令的命令行。在bsh/ksh/bash和csh中的语法都是`command`。

在ksh和bash中除了可以使用上面的语法外，又引入了一种新的语法，$(command)。

在ksh/bash环境下，使用$()显然比``优越，这是因为：
其一，前者更易读，不会产生歧义。而反引号`常常被初学者当成单引号'；
其二，前者嵌套时更简单，直接使用就行。而后者嵌套时内部的反引号必须用\转义；
其三，它们对反斜杠\的处理不一样，在$()中可以减少转义的麻烦。
而这一点与第二点是前因后果的关系。正是因为$()嵌套时不需转义，所以\在$()中就不需要作为一个特殊字符了。
而``中的\必须是特殊字符，否则就无法嵌套使用了。

那么我们是否可以完全抛弃``的语法，只用$()就好了呢？
这在大多数环境下是可行的，但如果过分强调这个的话，我认为还是太理想化了。
事实上``还是有它存在的理由的，因为它的兼容性最好，在bsh/ksh/bash/csh统统可以执行。
在大部分的传统Unix上是没有安装bash的，ksh是不是都有安装我不能确定(100%正宗的ksh好像是专有软件)，
还有在一些嵌入式的Linux或者高度裁剪的Linux上会没有安装bash或者ksh。
那么在这些环境下进行Shell编程时我们就可能不得不使用最古老的bourne shell语法，这时优秀的$()语法就可能完全派不上用场。

扯远了，回到我们的主题。
考察命令替换的执行机制，``或$()里面的内容原则上应该作为一个整体传递，交给子shell执行。
所以其中的大部分字符在传递给子shell之前都是普通字符。
那么实际上它们在本来命令替换的功能之外似乎也起到了一种引用的效果(也算是一种副产品吧)，
所以我们不妨把它看作上篇里面讲到的三种引用之外的另一种引用形式。

于是我们自然会问一个问题，在这两种“引用”中有没有例外的特殊字符呢？当然会有，据我目前所知(不全面的地方欢迎大家指正)：
``中的特殊字符有美元符$,反斜杠 \，双引号 "，单引号'，还有自身`。
$()中的特殊字符有美元符$, 双引号"和单引号'。

既然命令替换可以看作是一种特殊的引用，我们不妨拿上篇里反斜杠的例子再来研究一下。
假定我们要用两次echo,并且要做一次命令替换。先来看比较典型的ksh:
$ echo `echo \\\\`
\

我们先来简单解释一下这个命令的处理过程。
第一步，shell处理整个命令行，由于``中的\是特殊字符，所以处理之后传给内部的echo的参数就变成了\\；
第二步，在子shell中执行echo \\，因为ksh的echo缺省处理转义序列，所以\在echo看来还是特殊字符，于是内部echo输出一个\；
第三步，将内部echo输出的\代入外部的echo的命令行，执行echo '\'，最终输出一个\。

现在请大家猜一猜，ksh下为了要输出两个\，我们需要多少个\在命令行呢？大胆一点，使劲猜！
答案是20个(在bsh下也差不多，是18个)！
$ echo `echo \\\\\\\\\\\\\\\\\\\\`
\\

吃惊吗？你会说：“这太离谱了！这条裹脚布比前面那条长了几倍！”
是的，太离谱了，难怪有人把\(英文为backslash)的自身冗长又似乎没有规律可循的转义叫作：“backslashit！”;-D。
不过在抱怨过后还是让我们来看看有什么方法来简化一下吧。
ksh下:
第一件武器：强引用。防止在第一次命令行处理时解释\。
$ echo `echo '\\\\\\\\\\'`
\\
好刀！不错，10个\就够用了！

第二件武器：echo的-E选项，防止echo解释\。
$ echo -E `echo -E '\\\\'`
\\
连环双刀！只剩4个\了。

终极武器：$()。防止执行内部的echo时在子shell的命令行解释\。
$ echo -E $(echo -E '\\')
\\
枝枝杈杈砍精光，剩下两个对一双！这次终于达到最简了。

其他的shell情况如何呢？
bsh不支持$(...)的语法，`...`的情况与ksh类似，只是echo的处理与ksh稍有一点不同。
bash的情况类似，注意echo缺省不解释转移序列(等价于ksh的echo -E)。
tcsh不支持$(...)语法，`...`中情况也稍简单些：
$ echo $0
csh
$ echo `echo \\`
\
$echo `echo \\\\`
\\
$ echo `echo '\\'`
\\

tcsh与这个例子有关的引用方面的特点是：
单引号和双引号中的\为普通字符。
echo中\默认为普通字符。
``中\为特殊字符。
详细内容请参看csh的相关文档。

最后，让我们继续讨论上面那个dos路径的实际问题作为一个练习，为了叙述方便，对原问题略加改动：
#!/bin/ksh
dospath='c:\tmp'
escaped=`echo $dospath|sed 's/\\/&&/'`
echo $escaped

在ksh下执行上面的脚本报错：
sed：-e 表达式 #1，字符 7：unterminated `s' command
你能找出所有的错误吗？
根据出错信息，首先容易知道sed的命令行有问题。对了，哪里有问题？还是经常捣乱的\吧？又对了，怎样修改呢？
兼容性最好的语法：
escaped=`echo $dospath|sed 's/\\\\/&&/'`
OK，执行通过！

再来，最优雅的的语法：
escaped=$(echo $dospath|sed 's/\\/&&/')
很好！也通过。

重新执行脚本，输出：
c: mp
还不对，那么哪里还有错误呢？嗯，对了，是echo的问题。如何修改？
escaped=`echo -E $dospath|sed 's/\\\\/&&/'`
不错。再次执行脚本，输出：
c:\tmp
仍然不是我们想要的结果。哪里还有问题呢？对了，别忘了最后一个echo!
echo -E $escaped
再次执行脚本，输出：
c:\\tmp
大功告成！

OK!通过这上下两篇关于引用和反斜杠\的讨论，相信您对shell的引用和转义有了更加深入的理解。
让我们小结一下，帮助您强化记忆：
关于引用：
三种公认的引用方式：
强引用('...')，特殊字符：单引号'自身
弱引用("...")，特殊字符：双引号"自身，反斜杠\，美元符$，还有反引号`
转义(\.)，没有例外，连\自身也可以被转义。

woodie自己加入的两种“类引用”方式(一家之言，姑妄言之，姑妄听之吧。欢迎拍砖！^_^)：
``，bsh/ksh/bash/csh中可用，特殊字符：反引号自身`，美元符$，反斜杠\，还有单、双引号'和”。
$()，ksh/bash中可用，特殊字符有美元符$，还有单、双引号'和”。

关于echo：
bsh：解释转义字符序列，且不能关掉
ksh：缺省解释转义字符序列，可以用-E选项关掉
bash：缺省不解释转义字符序列，可以用-e选项打开

说明，我的测试环境：
Centos 4.2 x86-64
bash:        3.00.15(1)
ksh        pdksh-5.2.14-30.3
bsh        ash-0.3.8-20
csh        tcsh-6.13-9

## 10.引用规则和条件

引用规则和条件
下面是几种使用引用中的几种情况：
01.引用忽略单词边界
    echo "Hello; world"
    echo Hel"lo; w"orld
    上面结果是一样的。
------------------------------------------------------------------------------------------------------
02.在命令中的组合引用
    比如下例中有"",'',/
    echo The '$USER' variable contains this value \> "|$USER|"
------------------------------------------------------------------------------------------------------
    输出的结果是下面的样子：
    The $USER variable contains this value > |fred|
------------------------------------------------------------------------------------------------------
03.文件名中有特殊的字符
    举例：
    rm ch1*会删除全部那些文件名的前缀是ch1的文件。有一种特殊情况，例如下面假定你有下面这些文件在你的目录中：
    ch1 ch1* ch1a ch15
    注意其中有一个文件名是ch1*的文件，尽管这是不被推荐的，但是有时你会遇到他的名字中包含奇怪的字符。

    如果你想删除这个文件不能用下面这个命令：
    rm ch1*
    这样会删除全部你的ch1文件。相反，你可以引用（转义）这个特殊的字符用'',"",\。
    $rm 'ch1*'
    引用这个特殊的字符，去掉它的通配符含义使你可以删除这个文件。
------------------------------------------------------------------------------------------------------
04.正则表达式
    以后我会介绍另外一种通配符的用法叫正则表达式。
    grep '[0-9][0-9]*$' report2 report7
    被引用的字串 [0-9][0-9]*$ 就是一个正则表达式，它会在 report2 report7文件中查找正则表达式中的模式。
-------------------------------------------------------------------------------------------------------------------------------------
