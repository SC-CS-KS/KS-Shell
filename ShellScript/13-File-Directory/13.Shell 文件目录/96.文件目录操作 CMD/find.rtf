{\rtf1\fbidis\ansi\ansicpg0\uc1\deff0\deflang0\deflangfe0{\fonttbl{\f0\fnil \'cb\'ce\'cc\'e5;}{\f1\fnil \'ce\'a2\'c8\'ed\'d1\'c5\'ba\'da;}{\f2\fnil\fcharset134 \'cb\'ce\'cc\'e5;}{\f3\fnil\fcharset2 Symbol;}}{\colortbl;\red0\green0\blue255;\red255\green0\blue0;\red0\green0\blue0;\red255\green255\blue255;}{\*\listtable{\list\listtemplateid1759210891\listsimple1
{\listlevel\levelnfc23\leveljc0\li720\fi-360\jclisttab\tx720{\leveltext\'01\uc2\u183 \'a1\'a4\uc1;}{\levelnumbers;}\f3\fs24\lang1024}
\listid2099598267}
}
{\*\listoverridetable
{\listoverride\listid2099598267\listoverridecount0\ls1}
}


\pard\fi0\li0\qc\ri0\sb0\sa0\itap0 \plain \f2\b\lang2052\fs24\cf3 find
\par \pard\fi0\li0\ql\ri0\sb0\sa0\itap0 
\par \plain \f1\fs20 NAME
\par  \plain \f1\fs20\cf1       find - search for files in a directory hierarchy
\par \plain \f1\fs20 
\par SYNOPSIS
\par \plain \f1\fs20\cf2        find [-H] [-L] [-P] [-D debugopts] [-Olevel] [path...] [expression]
\par \plain \f1\fs20 
\par \plain \f1\b\fs20 DESCRIPTION
\par \plain \f1\fs20       \plain \f1\fs20\cf1  This  manual page documents the GNU version of find. \plain \f1\fs20  GNU find searches the directory tree\plain \f1\fs20\cf2  rooted at each given file name
\par        by evaluating the given expression from left to right\plain \f1\fs20 , according to the rules  of  \plain \f1\fs20\cf1 precedence (\uc2\u20248 \'d3\'c5\u20808 \'cf\'c8)\uc1\plain \f1\fs20  (see  section  OPERATORS),
\par        until the outcome is known (the left hand side is false for and operations, true for or), at which point find moves on to
\par        the next file name.
\par 
\par        If you are using find in an environment \plain \f1\fs20\cf1 where security is important\plain \f1\fs20  (for example if you are using it to seach directories
\par        that  are writable by other users), you should read the "Security Considerations" chapter of the findutils documentation,
\par        which is called Finding Files and comes with findutils.   That document also includes a lot more  detail  and  discussion
\par        than this manual page, so you may find it a more useful source of information.
\par 
\par \plain \f1\b\fs20 OPTIONS
\par \plain \f1\fs20        \plain \f1\fs20\cf1 The  -H,  -L and -P options control the treatment of \plain \f1\b\fs20\cf1 symbolic links(\uc2\u31526 \'b7\'fb\u21495 \'ba\'c5\u36830 \'c1\'ac\u32467 \'bd\'e1)\uc1\plain \f1\fs20\cf1 .\plain \f1\fs20   Command-line arguments following these are taken to
\par        be names of files or directories to be examined, up to the first argument that begins with `-', or the  argument  `('  or
\par        `!'.  That argument and any following arguments are taken to be the expression describing what is to be searched for.  \plain \f1\fs20\cf1 If
\par        no paths are given, the current directory is used.\plain \f1\fs20   If no expression is given, \plain \f1\fs20\cf1 the expression -print  is  used\plain \f1\fs20   (but  you
\par        should probably consider using -print0 instead, anyway).
\par 
\par        This  manual  page talks about `options' within the expression list.  These options control the behaviour of find but are
\par        specified immediately after the last path name.  The five `real' options -H, -L, -P, -D and -O  must  appear  before  the
\par        first  path  name,  if  at all.  A double dash -- can also be used to signal that any remaining arguments are not options
\par        (though ensuring that all start points begin with either `./' or `/' is generally safer if you use wildcards in the  list
\par        of start points).
\par 
\par      \plain \f1\fs20\cf1   -P     Never follow symbolic links.\plain \f1\fs20   This is the default behaviour.  When find examines or prints information a file, and
\par               the file is a symbolic link, the information used shall be taken from the properties of the symbolic link  itself.
\par 
\par 
\par        \plain \f1\fs20\cf1 -L     Follow  symbolic links.\plain \f1\fs20   When find examines or prints information about files, the information used shall be taken
\par               from the properties of the file to which the link points, not from the link itself (unless it is a broken symbolic
\par               link or find is unable to examine the file to which the link points).  Use of this option implies -noleaf.  If you
\par               later use the -P option, -noleaf will still be in effect.  If -L is in effect and find discovers a  symbolic  link
\par               to a subdirectory during its search, the subdirectory pointed to by the symbolic link will be searched.
\par 
\par               When  the  -L  option is in effect, the -type predicate will always match against the type of the file that a sym-
\par               bolic link points to rather than the link itself (unless the symbolic link is broken).  Using -L causes the -lname
\par               and -ilname predicates always to return false.
\par 
\par 
\par     \plain \f1\fs20\cf1    -H     Do  not  follow  symbolic links, except while processing the command line arguments.\plain \f1\fs20   When find examines or prints
\par               information about files, the information used shall be taken from the properties  of  the  symbolic  link  itself.
\par               The only exception to this behaviour is when a file specified on the command line is a symbolic link, and the link
\par               can be resolved.  For that situation, the information used is taken from whatever the link points to (that is, the
\par               link is followed).  The information about the link itself is used as a fallback if the file pointed to by the sym-
\par               bolic link cannot be examined.  If -H is in effect and one of the paths specified on the command line  is  a  sym-
\par               bolic  link  to  a  directory, the contents of that directory will be examined (though of course -maxdepth 0 would
\par               prevent this).
\par 
\par      \plain \f1\fs20\cf1   If more than one of -H, -L and -P is specified, each overrides the others; the last one appearing  on  the  command  line
\par        takes  effect. \plain \f1\fs20   \plain \f1\fs20\cf1 Since  it  is  the default, the -P option should be considered to be in effect\plain \f1\fs20  unless either -H or -L is
\par        specified.
\par 
\par        GNU find frequently stats files during the processing of the command line itself, before any searching has begun.   These
\par        options  also  affect  how  those  arguments are processed.  Specifically, there are a number of tests that compare files
\par        listed on the command line against a file we are currently considering.  In each case, the file specified on the  command
\par        line  will  have  been examined and some of its properties will have been saved.  If the named file is in fact a symbolic
\par        link, and the -P option is in effect (or if neither -H nor -L were specified), the information used  for  the  comparison
\par        will  be taken from the properties of the symbolic link.  Otherwise, it will be taken from the properties of the file the
\par        link points to.  If find cannot follow the link (for example because it has insufficient privileges or the link points to
\par        a nonexistent file) the properties of the link itself will be used.
\par 
\par        When  the  -H  or -L options are in effect, any symbolic links listed as the argument of -newer will be dereferenced, and
\par        the timestamp will be taken from the file to which the symbolic link points.  The same consideration applies to -newerXY,
\par        -anewer and -cnewer.
\par 
\par        The  -follow  option  has a similar effect to -L, though it takes effect at the point where it appears (that is, if -L is
\par        not used but -follow is, any symbolic links appearing after -follow on the command line will be dereferenced,  and  those
\par        before it will not).
\par 
\par 
\par        -D debugoptions
\par             \plain \f1\fs20\cf1   Print  diagnostic  information;\plain \f1\fs20  \plain \f1\fs20\cf1 this can be helpful to diagnose problems with why find is not doing what you want.
\par \plain \f1\fs20               The list of debug options should be comma separated.  Compatibility of the debug options is not guaranteed between
\par               releases  of  findutils.  For a complete list of valid debug options, see the output of find -D help.  Valid debug
\par               options include
\par               help   Explain the debugging options
\par               tree   Show the expression tree in its original and optimised form.
\par               stat   Print messages as files are examined with the stat and lstat system calls.  The find program tries to  min-
\par                      imise such calls.
\par               opt    Prints diagnostic information relating to the optimisation of the expression tree; see the -O option.
\par               rates  Prints a summary indicating how often each predicate succeeded or failed.
\par 
\par       \plain \f1\fs20\cf1  -Olevel
\par               Enables  query  optimisation\uc2\u65288 \'a3\'a8\uc1\plain \f1\fs20 \uc2\u26368 \'d7\'ee\u20248 \'d3\'c5\u21270 \'bb\'af\uc1\plain \f1\fs20\cf1 \uc2\u65289 \'a3\'a9.  \uc1\plain \f1\fs20  The find program reorders tests to speed up execution while preserving the overall
\par               effect; that is, predicates with side effects are not reordered relative to each other.   The  optimisations  per-
\par               formed at each optimisation level are as follows.
\par               0      Equivalent to optimisation level 1.
\par               1      This  is  the  default  optimisation  level  and corresponds to the traditional behaviour.  Expressions are
\par                      reordered so that tests based only on the names of files (for  example  -name  and  -regex)  are  performed
\par                      first.
\par               2      Any  -type  or  -xtype tests are performed after any tests based only on the names of files, but before any
\par                      tests that require information from the inode.  On many modern versions of Unix, file types are returned by
\par                      readdir() and so these predicates are faster to evaluate than predicates which need to stat the file first.
\par               3      At this optimisation level, the full cost-based query optimiser is enabled.  The order of tests is modified
\par                      so  that cheap (i.e. fast) tests are performed first and more expensive ones are performed later, if neces-
\par                      sary.  Within each cost band, predicates are evaluated earlier or  later  according  to  whether  they  are
\par                      likely  to  succeed  or not.  For -o, predicates which are likely to succeed are evaluated earlier, and for
\par                      -a, predicates which are likely to fail are evaluated earlier.
\par 
\par               The cost-based optimiser has a fixed idea of how likely any given test is to succeed.  In some cases the probabil-
\par               ity takes account of the specific nature of the test (for example, -type f is assumed to be more likely to succeed
\par               than -type c).  The cost-based optimiser is currently being evaluated.   If it does not actually improve the  per-
\par               formance  of  find,  it  will  be  removed again.  Conversely, optimisations that prove to be reliable, robust and
\par               effective may be enabled at lower optimisation levels over time.  However, the default behaviour  (i.e.  optimisa-
\par               tion  level  1)  will  not be changed in the 4.3.x release series.  The findutils test suite runs all the tests on
\par               find at each optimisation level and ensures that the result is the same.
\par 
\par \plain \f1\b\fs20 EXPRESSIONS
\par \plain \f1\fs20        The expression is made up of options (which affect overall operation rather than the processing of a specific  file,  and
\par        always  return  true), tests (which return a true or false value), and actions (which have side effects and return a true
\par        or false value), all separated by operators.  -and is assumed where the operator is omitted.
\par 
\par        If the expression contains no actions other than -prune, -print is performed on all files for  which  the  expression  is
\par        true.
\par 
\par \plain \f1\b\fs20 OPTIONS
\par \plain \f1\fs20        All  options  always  return true.  Except for -daystart, -follow and -regextype, the options affect all tests, including
\par        tests specified before the option.  This is because the options are processed when the command line is parsed, while  the
\par        tests  don't  do  anything until files are examined.  The -daystart, -follow and -regextype options are different in this
\par        respect, and have an effect only on tests which appear later in the command line.  Therefore, for clarity, it is best  to
\par        place them at the beginning of the expression.  A warning is issued if you don't do this.
\par 
\par \plain \f1\fs20\cf2        -d     A synonym for -depth, for compatibility with FreeBSD, NetBSD, MacOS X and OpenBSD
\par \plain \f1\fs20 
\par        -daystart
\par               Measure  times  (for -amin, -atime, -cmin, -ctime, -mmin, and -mtime) from the beginning of today rather than from
\par               24 hours ago.  This option only affects tests which appear later on the command line.
\par 
\par     \plain \f1\fs20\cf1    -depth 
\par               Process each directory's contents before the directory itself.\plain \f1\fs20   \plain \f1\fs20\cf1 The -delete action also implies -depth.
\par \plain \f1\fs20 
\par        -follow
\par               Deprecated; use the -L option instead.  Dereference symbolic links.  Implies -noleaf.  The -follow option  affects
\par               only  those  tests  which appear after it on the command line.  Unless the -H or -L option has been specified, the
\par               position of the -follow option changes the behaviour of the -newer predicate; any files listed as the argument  of
\par               -newer  will  be dereferenced if they are symbolic links.  The same consideration applies to -newerXY, -anewer and
\par               -cnewer.  Similarly, the -type predicate will always match against the type of  the  file  that  a  symbolic  link
\par               points  to  rather  than the link itself.  Using -follow causes the -lname and -ilname predicates always to return
\par               false.
\par 
\par        -help, --help
\par               Print a summary of the command-line usage of find and exit.
\par 
\par        -ignore_readdir_race
\par            \plain \f1\fs20\cf1    Normally, find will emit an error message when it fails to stat a file. \plain \f1\fs20  If you give this option  and  a  file  is
\par               deleted  between  the  time  find  reads the name of the file from the directory and the time it tries to stat the
\par               file, no error message will be issued.    This also applies to files or directories whose names are given  on  the
\par               command  line.   This option takes effect at the time the command line is read, which means that you cannot search
\par               one part of the filesystem with this option on and part of it with this option off (if you need to  do  that,  you
\par               will need to issue two find commands instead, one with the option and one without it).
\par 
\par        -maxdepth levels
\par               Descend at most levels (a non-negative integer) of directories below the command line arguments.  \plain \f1\fs20\cf1 -maxdepth
\par               0 means only apply the tests and actions to the command line arguments.
\par \plain \f1\fs20 
\par        \plain \f1\fs20\cf1 -mindepth levels
\par               Do not apply any tests or actions at levels less than levels (a non-negative integer). \plain \f1\fs20  -mindepth 1 means  process
\par               all files except the command line arguments.
\par 
\par        -mount Don't  descend  directories  on other filesystems.  An alternate name for -xdev, for compatibility with some other
\par               versions of find.
\par 
\par        -noignore_readdir_race
\par               Turns off the effect of -ignore_readdir_race.
\par 
\par        -noleaf
\par               Do not optimize by assuming that directories contain 2 fewer subdirectories than  their  hard  link  count.   This
\par               option  is needed when searching filesystems that do not follow the Unix directory-link convention, such as CD-ROM
\par               or MS-DOS filesystems or AFS volume mount points.  Each directory on a normal Unix filesystem has at least 2  hard
\par               links:  its  name and its `.'  entry.  Additionally, its subdirectories (if any) each have a `..'  entry linked to
\par               that directory.  When find is examining a directory, after it has statted 2 fewer subdirectories than  the  direc-
\par               tory's link count, it knows that the rest of the entries in the directory are non-directories (`leaf' files in the
\par               directory tree).  If only the files' names need to be examined, there is no need to stat them; this gives  a  sig-
\par               nificant increase in search speed.
\par 
\par       -regextype type
\par               Changes  the  regular  expression  syntax  understood by -regex and -iregex tests which occur later on the command
\par               line.  Currently-implemented types are emacs (this is the default), posix-awk, posix-basic, posix-egrep and posix-
\par               extended.
\par 
\par        -version, --version
\par               Print the find version number and exit.
\par 
\par        -warn, -nowarn
\par               Turn  warning messages on or off.  These warnings apply only to the command line usage, not to any conditions that
\par               find might encounter when it searches directories.  The default behaviour corresponds to -warn if  standard  input
\par               is a tty, and to -nowarn otherwise.
\par 
\par        -xdev  Don't descend directories on other filesystems.
\par 
\par \plain \f1\b\fs20 TESTS
\par \plain \f1\fs20        Some  tests, for example -newerXY and -samefile, allow comparison between the file currently being examined and some ref-
\par        erence file specified on the command line.  When these tests are used, the interpretation of the reference file is deter-
\par        mined  by  the  options -H, -L and -P and any previous -follow, but the reference file is only examined once, at the time
\par        the command line is parsed.  If the reference file cannot be examined (for example, the stat(2)  system  call  fails  for
\par        it), an error message is issued, and find exits with a nonzero status.
\par        Numeric arguments can be specified as
\par 
\par        +n     for greater than n,
\par 
\par        -n     for less than n,
\par 
\par        n      for exactly n.
\par \plain \f1\fs20\cf1 
\par        -amin n
\par \plain \f1\fs20               File was last accessed n minutes ago.
\par \plain \f1\fs20\cf1        -anewer file
\par \plain \f1\fs20               File  was last accessed more recently than file was modified.  If file is a symbolic link and the -H option or the
\par               -L option is in effect, the access time of the file it points to is always used.
\par \plain \f1\fs20\cf1        -atime n
\par \plain \f1\fs20               File was last accessed n*24 hours ago.  When find figures out how many 24-hour  periods  ago  the  file  was  last
\par               accessed,  any  fractional  part  is ignored, so to match -atime +1, a file has to have been accessed at least two
\par               days ago.
\par \plain \f1\fs20\cf1        -cmin n
\par \plain \f1\fs20               File's status was last changed n minutes ago.
\par        -cnewer file
\par               File's status was last changed more recently than file was modified.  If file is a symbolic link and the -H option
\par               or the -L option is in effect, the status-change time of the file it points to is always used.
\par        -ctime n
\par               File's status was last changed n*24 hours ago.  See the comments for -atime to understand how rounding affects the
\par               interpretation of file status change times.
\par    \plain \f1\fs20\cf1     -empty File is empty and is either a regular file or a directory.
\par        -executable
\par \plain \f1\fs20               Matches files which are executable and directories which are searchable (in a file name resolution  sense).   This
\par               takes  into  account access control lists and other permissions artefacts which the -perm test ignores.  This test
\par               makes use of the access(2) system call, and so can be fooled by NFS servers which do UID mapping (or  root-squash-
\par               ing),  since  many  systems  implement  access(2) in the client's kernel and so cannot make use of the UID mapping
\par               information held on the server.  Because this test is based only on the result of the access(2) system call, there
\par               is no guarantee that a file for which this test succeeds can actually be executed.
\par \plain \f1\fs20\cf1        -false Always false.
\par        -fstype type
\par \plain \f1\fs20               File is on a filesystem of type type.  The valid filesystem types vary among different versions of Unix; an incom-
\par               plete list of filesystem types that are accepted on some version of Unix or another is: ufs, 4.2, 4.3,  nfs,  tmp,
\par               mfs, S51K, S52K.  You can use -printf with the %F directive to see the types of your filesystems.
\par \plain \f1\fs20\cf1        -gid n File's numeric group ID is n.
\par        -group gname
\par \plain \f1\fs20               File belongs to group gname (numeric group ID allowed).
\par        -ilname pattern
\par               Like  -lname,  but  the match is case insensitive.  If the -L option or the -follow option is in effect, this test
\par               returns false unless the symbolic link is broken.
\par        -iname pattern
\par               Like -name, but the match is case insensitive.  For example, the patterns `fo*' and `F??'  match  the  file  names
\par               `Foo',  `FOO',  `foo', `fOo', etc.   In these patterns, unlike filename expansion by the shell, an initial '.' can
\par               be matched by `*'.  That is, find -name *bar will match the file `.foobar'.   Please note that  you  should  quote
\par               patterns as a matter of course, otherwise the shell will expand any wildcard characters in them.
\par        -inum n
\par               File has inode number n.  It is normally easier to use the -samefile test instead.
\par        -ipath pattern
\par               Behaves in the same way as -iwholename.  This option is deprecated, so please do not use it.
\par        -iregex pattern
\par               Like -regex, but the match is case insensitive.
\par        -iwholename pattern
\par               Like -wholename, but the match is case insensitive.
\par \plain \f1\fs20\cf1        -links n
\par \plain \f1\fs20               File has n links.
\par        -lname pattern
\par               File  is  a  symbolic link whose contents match shell pattern pattern.  The metacharacters do not treat `/' or `.'
\par               specially.  If the -L option or the -follow option is in effect, this test returns false unless the symbolic  link
\par               is broken.
\par        -mmin n
\par               File's data was last modified n minutes ago.
\par        -mtime n
\par               File's  data was last modified n*24 hours ago.  See the comments for -atime to understand how rounding affects the
\par               interpretation of file modification times.
\par \plain \f1\fs20\cf2        -name pattern
\par \plain \f1\fs20               Base of file name (the path with the leading directories removed) matches shell pattern pattern.  The  metacharac-
\par               ters (`*', `?', and `[]') match a `.' at the start of the base name (this is a change in findutils-4.2.2; see sec-
\par               tion STANDARDS CONFORMANCE below).  To ignore a directory and the files under it, use -prune; see  an  example  in
\par               the description of -path.  Braces are not recognised as being special, despite the fact that some shells including
\par               Bash imbue braces with a special meaning in shell patterns.  The filename matching is performed with  the  use  of
\par               the  fnmatch(3)  library  function.    \plain \f1\fs20\cf1 Don't  forget  to enclose the pattern in quotes in order to protect it from
\par               expansion by the shell.
\par \plain \f1\fs20        -newer file
\par               File was modified more recently than file.  If file is a symbolic link and the -H option or the -L  option  is  in
\par               effect, the modification time of the file it points to is always used.
\par        -newerXY reference
\par               Compares  the timestamp of the current file with reference.  The reference argument is normally the name of a file
\par               (and one of its timestamps is used for the comparison) but it may also be a string describing an absolute time.  X
\par               and  Y  are placeholders for other letters, and these letters select which time belonging to how reference is used
\par               for the comparison.
\par 
\par               a   The access time of the file reference
\par               B   The birth time of the file reference
\par               c   The inode status change time of reference
\par               m   The modification time of the file reference
\par               t   reference is interpreted directly as a time
\par 
\par               Some combinations are invalid; for example, it is invalid for X to be t.  Some combinations are not implemented on
\par               all  systems;  for  example  B is not supported on all systems.  If an invalid or unsupported combination of XY is
\par               specified, a fatal error results.  Time specifications are interpreted as for the argument to the -d option of GNU
\par               date.   If  you  try  to  use the birth time of a reference file, and the birth time cannot be determined, a fatal
\par               error message results.  If you specify a test which refers to the birth time of files being  examined,  this  test
\par               will fail for any files where the birth time is unknown.
\par        -nogroup
\par               No group corresponds to file's numeric group ID.
\par        -nouser
\par               No user corresponds to file's numeric user ID.
\par \plain \f1\fs20\cf1        -path pattern
\par \plain \f1\fs20               File name matches shell pattern pattern.  The metacharacters do not treat `/' or `.' specially; so, for example,
\par                         find . -path "./sr*sc"
\par               will  print  an  entry for a directory called `./src/misc' (if one exists).  To ignore a whole directory tree, use
\par               -prune rather than checking every file in the tree.  For example, to skip the directory `src/emacs' and all  files
\par               and directories under it, and print the names of the other files found, do something like this:
\par                         find . -path ./src/emacs -prune -o -print
\par               Note  that  the  pattern match test applies to the whole file name, starting from one of the start points named on
\par               the command line.  It would only make sense to use an absolute path name here if the relevant start point is  also
\par               an absolute path.  This means that this command will never match anything:
\par                         find bar -path /foo/bar/myfile -print
\par               The predicate -path is also supported by HP-UX find and will be in a forthcoming version of the POSIX standard.
\par        -perm mode
\par               File's permission bits are exactly mode (octal or symbolic).  Since an exact match is required, if you want to use
\par               this form for symbolic modes, you may have to specify a rather complex mode string.  For example  -perm  g=w  will
\par               only match files which have mode 0020 (that is, ones for which group write permission is the only permission set).
\par               It is more likely that you will want to use the `/' or `-' forms, for example -perm -g=w, which matches  any  file
\par               with group write permission.  See the EXAMPLES section for some illustrative examples.
\par        -perm -mode
\par               All  of the permission bits mode are set for the file.  Symbolic modes are accepted in this form, and this is usu-
\par               ally the way in which would want to use them.  You must specify `u', `g' or `o' if you use a symbolic mode.    See
\par               the EXAMPLES section for some illustrative examples.
\par        -perm /mode
\par               Any of the permission bits mode are set for the file.  Symbolic modes are accepted in this form.  You must specify
\par               `u', `g' or `o' if you use a symbolic mode.  See the EXAMPLES section for some illustrative examples.  If no  per-
\par               mission bits in mode are set, this test currently matches no files.  However, it will soon be changed to match any
\par               file (the idea is to be more consistent with the behaviour of -perm -000).
\par        -perm +mode
\par               Deprecated, old way of searching for files with any of the permission bits in mode  set.   You  should  use  -perm
\par               /mode  instead.  Trying  to  use  the  `+' syntax with symbolic modes will yield surprising results.  For example,
\par               `+u+x' is a valid symbolic mode (equivalent to +u,+x, i.e. 0111) and will therefore  not  be  evaluated  as  -perm
\par               +mode  but  instead  as  the  exact  mode specifier -perm mode and so it matches files with exact permissions 0111
\par               instead of files with any execute bit set.  If you found this paragraph confusing, you're not  alone  -  just  use
\par        -perm  /mode.   
\par               This form of the -perm test is deprecated because the POSIX specification requires the interpreta-
\par               tion of a leading `+' as being part of a symbolic mode, and so we switched to using `/' instead.
\par \plain \f1\fs20\cf1        -readable
\par \plain \f1\fs20               Matches files which are readable.  This takes into account access control lists and  other  permissions  artefacts
\par               which  the  -perm  test  ignores.   This  test makes use of the access(2) system call, and so can be fooled by NFS
\par               servers which do UID mapping (or root-squashing), since many systems implement access(2) in  the  client's  kernel
\par               and so cannot make use of the UID mapping information held on the server.
\par \plain \f1\fs20\cf1        -regex pattern
\par \plain \f1\fs20               File  name  matches regular expression pattern.  This is a match on the whole path, not a search.  For example, to
\par               match a file named `./fubar3', you can use the regular expression `.*bar.' or `.*b.*3', but not `f.*r3'.  The reg-
\par               ular  expressions  understood  by  find are by default Emacs Regular Expressions, but this can be changed with the
\par               -regextype option.
\par        -samefile name
\par               File refers to the same inode as name.   When -L is in effect, this can include symbolic links.
\par  \plain \f1\fs20\cf1       -size n[cwbkMG]
\par \plain \f1\fs20               File uses n units of space.  The following suffixes can be used:
\par               `b'    for 512-byte blocks (this is the default if no suffix is used)
\par               `c'    for bytes
\par               `w'    for two-byte words
\par               `k'    for Kilobytes (units of 1024 bytes)
\par               `M'    for Megabytes (units of 1048576 bytes)
\par               `G'    for Gigabytes (units of 1073741824 bytes)
\par 
\par               The size does not count indirect blocks, but it does count blocks in sparse files that are not actually allocated.
\par               Bear  in mind that the `%k' and `%b' format specifiers of -printf handle sparse files differently.  The `b' suffix
\par               always denotes 512-byte blocks and never 1 Kilobyte blocks, which is different to the behaviour of -ls.
\par \plain \f1\fs20\cf2        -true  Always true.
\par \plain \f1\fs20\cf1        -type c
\par \plain \f1\fs20               File is of type c:
\par               b      block (buffered) special
\par               c      character (unbuffered) special
\par               d      directory
\par               p      named pipe (FIFO)
\par               f      regular file
\par               l      symbolic link; this is never true if the -L option or the -follow option is in effect, unless the  symbolic
\par                      link is broken.  If you want to search for symbolic links when -L is in effect, use -xtype.
\par               s      socket
\par               D      door (Solaris)
\par        -uid n File's numeric user ID is n.
\par        -used n
\par               File was last accessed n days after its status was last changed.
\par        -user uname
\par               File is owned by user uname (numeric user ID allowed).
\par        -wholename pattern
\par               See -path.    This alternative is less portable than -path.
\par        -writable
\par               Matches  files  which  are writable.  This takes into account access control lists and other permissions artefacts
\par               which the -perm test ignores.  This test makes use of the access(2) system call, and  so  can  be  fooled  by  NFS
\par               servers  which  do  UID mapping (or root-squashing), since many systems implement access(2) in the client's kernel
\par               and so cannot make use of the UID mapping information held on the server.
\par        -xtype c
\par               The same as -type unless the file is a symbolic link.  For symbolic links: if the -H or -P option  was  specified,
\par               true  if  the  file  is  a  link to a file of type c; if the -L option has been given, true if c is `l'.  In other
\par               words, for symbolic links, -xtype checks the type of the file that -type does not check.
\par        -context pattern
\par               (SELinux only) Security context of the file matches glob pattern.
\par  \plain \f1\b\fs20 ACTIONS
\par \plain \f1\fs20        -delete
\par               Delete files; true if removal succeeded.  If the removal failed, an error message is issued.   If  -delete  fails,
\par               find's  exit  status will be nonzero (when it eventually exits).  Use of -delete automatically turns on the -depth
\par               option.
\par 
\par               Warnings: Don't forget that the find command line is evaluated as an expression, so  putting  -delete  first  will
\par               make find try to delete everything below the starting points you specified.  When testing a find command line that
\par               you later intend to use with -delete, you should explicitly specify -depth in  order  to  avoid  later  surprises.
\par               Because -delete implies -depth, you cannot usefully use -prune and -delete together.
\par 
\par   \plain \f1\fs20\cf2      -exec command ;
\par \plain \f1\fs20               Execute  command;  true if 0 status is returned.  All following arguments to find are taken to be arguments to the
\par               command until an argument consisting of `;' is encountered.  The string `\{\}' is replaced by the current file  name
\par               being  processed everywhere it occurs in the arguments to the command, not just in arguments where it is alone, as
\par               in some versions of find.  Both of these constructions might need to be escaped (with a `\\') or quoted to  protect
\par               them  from  expansion  by  the  shell.  See the EXAMPLES section for examples of the use of the -exec option.  The
\par               specified command is run once for each matched file.  The command is executed in the starting  directory.    There
\par               are unavoidable security problems surrounding use of the -exec action; you should use the -execdir option instead.
\par 
\par \plain \f1\fs20\cf2        -exec command \{\} +
\par \plain \f1\fs20               This variant of the -exec action runs the specified command on the selected files, but the command line  is  built
\par               by  appending each selected file name at the end; the total number of invocations of the command will be much less
\par               than the number of matched files.  The command line is built in much the same way that xargs  builds  its  command
\par               lines.   Only  one instance of `\{\}' is allowed within the command.  The command is executed in the starting direc-
\par               tory.
\par 
\par        -execdir command ;
\par        -execdir command \{\} +
\par               Like -exec, but the specified command is run from the subdirectory containing the matched file, which is not  nor-
\par               mally the directory in which you started find.  This a much more secure method for invoking commands, as it avoids
\par               race conditions during resolution of the paths to the matched files.  As with the -exec action, the  `+'  form  of
\par               -execdir will build a command line to process more than one matched file, but any given invocation of command will
\par               only list files that exist in the same subdirectory.  If you use this option, you  must  ensure  that  your  $PATH
\par               environment  variable  does not reference `.'; otherwise, an attacker can run any commands they like by leaving an
\par               appropriately-named file in a directory in which you will run -execdir.  The same applies  to  having  entries  in
\par               $PATH which are empty or which are not absolute directory names.
\par        -fls file
\par               True;  like -ls but write to file like -fprint.  The output file is always created, even if the predicate is never
\par               matched.  See the UNUSUAL FILENAMES section for information about how unusual characters in filenames are handled.
\par        -fprint file
\par               True; print the full file name into file file.  If file does not exist when find is run, it is created; if it does
\par               exist, it is truncated.  The file names ``/dev/stdout'' and ``/dev/stderr'' are handled specially; they  refer  to
\par               the standard output and standard error output, respectively.  The output file is always created, even if the pred-
\par               icate is never matched.  See the UNUSUAL FILENAMES section for information about how unusual characters  in  file-
\par               names are handled.
\par        -fprint0 file
\par               True;  like  -print0  but write to file like -fprint.  The output file is always created, even if the predicate is
\par               never matched.  See the UNUSUAL FILENAMES section for information about how unusual characters  in  filenames  are
\par               handled.
\par \plain \f1\fs20\cf2        -fprintf file format
\par \plain \f1\fs20               True;  like  -printf  but write to file like -fprint. \plain \f1\fs20\cf1  The output file is always created, even if the predicate is
\par               never matched.  \plain \f1\fs20 See the UNUSUAL FILENAMES section for information about how unusual characters  in  filenames  are
\par               handled.
\par     \plain \f1\fs20\cf2    -ls    True;  list  current  file  in  ls -dils format on standard output. \plain \f1\fs20  The block counts are of 1K blocks, unless the
\par               environment variable POSIXLY_CORRECT is set, in which case 512-byte blocks are used.  See  the  UNUSUAL  FILENAMES
\par               section for information about how unusual characters in filenames are handled.
\par        -ok command ;
\par               Like  -exec but ask the user first (on the standard input); if the response does not start with `y' or `Y', do not
\par               run the command, and return false.  If the command is run, its standard input is redirected from /dev/null.
\par        -okdir command ;
\par               Like -execdir but ask the user first (on the standard input); if the response does not start with `y' or  `Y',  do
\par               not run the command, and return false.  If the command is run, its standard input is redirected from /dev/null.
\par 
\par        -print True;  print  the  full file name on the standard output, followed by a newline.   If you are piping the output of
\par               find into another program and there is the faintest possibility that the files which you are searching  for  might
\par               contain a newline, then you should seriously consider using the -print0 option instead of -print.  See the UNUSUAL
\par               FILENAMES section for information about how unusual characters in filenames are handled.
\par 
\par \plain \f1\fs20\cf1   \plain \f1\fs20\cf2      -print0
\par \plain \f1\fs20               True; print the full file name on the standard output, followed by a null character (instead of the newline  char-
\par               acter  that  -print  uses).  This allows file names that contain newlines or other types of white space to be cor-
\par               rectly interpreted by programs that process the find output. \plain \f1\fs20\cf2  This option corresponds to the -0 option of xargs.
\par \plain \f1\fs20 
\par   \plain \f1\fs20\cf1      -printf format
\par \plain \f1\fs20               True; print format on the standard output, interpreting `\\' escapes and `%' directives.  Field widths  and  preci-
\par               sions  can  be  specified  as with the `printf' C function.  Please note that many of the fields are printed as %s
\par               rather than %d, and this may mean that flags don't work as you might expect.  This also means that  the  `-'  flag
\par               does  work (it forces fields to be left-aligned).  Unlike -print, -printf does not add a newline at the end of the
\par               string.  The escapes and directives are:
\par               \\a     Alarm bell.
\par               \\b     Backspace.
\par               \\c     Stop printing from this format immediately and flush the output.
\par               \\f     Form feed.
\par               \\n     Newline.
\par               \\r     Carriage return.
\par               \\t     Horizontal tab.
\par               \\v     Vertical tab.
\par               \\      ASCII NUL.
\par               \\\\     A literal backslash (`\\').
\par               \\NNN   The character whose ASCII code is NNN (octal).
\par               A `\\' character followed by any other character is treated as an ordinary character, so they both are printed.
\par               %%     A literal percent sign.
\par               %a     File's last access time in the format returned by the C `ctime' function.
\par               %Ak    File's last access time in the format specified by k, which is either `@' or a directive for the  C  `strf-
\par                      time'  function.   The  possible  values for k are listed below; some of them might not be available on all
\par                      systems, due to differences in `strftime' between systems.
\par                       @      seconds since Jan. 1, 1970, 00:00 GMT, with fractional part.
\par                      Time fields:
\par                       H      hour (00..23)
\par                       I      hour (01..12)
\par                       k      hour ( 0..23)
\par                       l      hour ( 1..12)
\par                       M      minute (00..59)
\par                       p      locale's AM or PM
\par                       r      time, 12-hour (hh:mm:ss [AP]M)
\par                       S      Second (00.00 .. 61.00).  There is a fractional part.
\par                       T      time, 24-hour (hh:mm:ss)
\par                       +      Date and time, separated by `+', for example `2004-04-28+22:22:05.0'.  This  is  a  GNU  extension.
\par                              The  time  is  given  in  the current timezone (which may be affected by setting the TZ environment
\par                              variable).  The seconds field includes a fractional part.
\par                       X      locale's time representation (H:M:S)
\par                       Z      time zone (e.g., EDT), or nothing if no time zone is determinable
\par 
\par                      Date fields:
\par                       a      locale's abbreviated weekday name (Sun..Sat)
\par                       A      locale's full weekday name, variable length (Sunday..Saturday)
\par                       b      locale's abbreviated month name (Jan..Dec)
\par                       B      locale's full month name, variable length (January..December)
\par                       c      locale's date and time (Sat Nov 04 12:02:33 EST 1989).  The format is the same as for ctime(3)  and
\par                              so to preserve compatibility with that format, there is no fractional part in the seconds field.
\par                       d      day of month (01..31)
\par                       D      date (mm/dd/yy)
\par                       h      same as b
\par                       j      day of year (001..366)
\par                       m      month (01..12)
\par                       U      week number of year with Sunday as first day of week (00..53)
\par                       w      day of week (0..6)
\par                       W      week number of year with Monday as first day of week (00..53)
\par                       x      locale's date representation (mm/dd/yy)
\par                       y      last two digits of year (00..99)
\par                       Y      year (1970...)
\par 
\par               %b     The  amount of disk space used for this file in 512-byte blocks. Since disk space is allocated in multiples
\par                      of the filesystem block size this is usually greater than %s/512, but it can also be smaller if the file is
\par                      a sparse file.
\par               %c     File's last status change time in the format returned by the C `ctime' function.
\par               %Ck    File's last status change time in the format specified by k, which is the same as for %A.
\par               %d     File's depth in the directory tree; 0 means the file is a command line argument.
\par               %D     The device number on which the file exists (the st_dev field of struct stat), in decimal.
\par               %f     File's name with any leading directories removed (only the last element).
\par               %F     Type of the filesystem the file is on; this value can be used for -fstype.
\par               %g     File's group name, or numeric group ID if the group has no name.
\par               %G     File's numeric group ID.
\par               %h     Leading directories of file's name (all but the last element).  If the file name contains no slashes (since
\par                      it is in the current directory) the %h specifier expands to ".".
\par               %H     Command line argument under which file was found.
\par               %i     File's inode number (in decimal).
\par               %k     The amount of disk space used for this file in 1K blocks. Since disk space is allocated in multiples of the
\par                      filesystem  block  size  this  is usually greater than %s/1024, but it can also be smaller if the file is a
\par                      sparse file.
\par               %l     Object of symbolic link (empty string if file is not a symbolic link).
\par               %m     File's permission bits (in octal).  This option uses the `traditional' numbers which most Unix  implementa-
\par                      tions  use,  but  if your particular implementation uses an unusual ordering of octal permissions bits, you
\par                      will see a difference between the actual value of the file's mode and the output of %m.   Normally you will
\par                      want  to have a leading zero on this number, and to do this, you should use the # flag (as in, for example,
\par                      `%#m').
\par               %M     File's permissions (in symbolic form, as for ls).  This directive  is  supported  in  findutils  4.2.5  and
\par                      later.
\par               %n     Number of hard links to file.
\par               %p     File's name.
\par               %P     File's name with the name of the command line argument under which it was found removed.
\par               %s     File's size in bytes.
\par               %S     File's  sparseness.   This  is calculated as (BLOCKSIZE*st_blocks / st_size).  The exact value you will get
\par                      for an ordinary file of a certain length is system-dependent.  However, normally  sparse  files  will  have
\par                      values less than 1.0, and files which use indirect blocks may have a value which is greater than 1.0.   The
\par                      value used for BLOCKSIZE is system-dependent, but is usually 512 bytes.   If the file  size  is  zero,  the
\par                      value printed is undefined.  On systems which lack support for st_blocks, a file's sparseness is assumed to
\par                      be 1.0.
\par               %t     File's last modification time in the format returned by the C `ctime' function.
\par               %Tk    File's last modification time in the format specified by k, which is the same as for %A.
\par               %u     File's user name, or numeric user ID if the user has no name.
\par               %U     File's numeric user ID.
\par               %y     File's type (like in ls -l), U=unknown type (shouldn't happen)
\par               %Y     File's type (like %y), plus follow symlinks: L=loop, N=nonexistent
\par               %Z     (SELinux only) file's security context.
\par               A `%' character followed by any other character is discarded, but the other character is printed  (don't  rely  on
\par               this,  as  further format characters may be introduced).  A `%' at the end of the format argument causes undefined
\par               behaviour since there is no following character.  In some locales, it may hide your door keys, while in others  it
\par               may remove the final page from the novel you are reading.
\par 
\par               The  %m  and %d directives support the # , 0 and + flags, but the other directives do not, even if they print num-
\par               bers.  Numeric directives that do not support these flags include G, U, b, D, k and n.  The  `-'  format  flag  is
\par               supported and changes the alignment of a field from right-justified (which is the default) to left-justified.
\par 
\par               See the UNUSUAL FILENAMES section for information about how unusual characters in filenames are handled.
\par 
\par        -prune True;  if  the file is a directory, do not descend into it. If -depth is given, false; no effect.  Because -delete
\par               implies -depth, you cannot usefully use -prune and -delete together.
\par        -quit  Exit immediately.  No child processes will be left running, but no more paths specified on the command  line  will
\par               be processed.  For example, find /tmp/foo /tmp/bar -print -quit will print only /tmp/foo.  Any command lines which
\par               have been built up with -execdir ... \{\} + will be invoked before find exits.   The exit status may or may  not  be
\par               zero, depending on whether an error has already occurred.
\par 
\par 
\par    UNUSUAL FILENAMES
\par        Many of the actions of find result in the printing of data which is under the control of other users.  This includes file
\par        names, sizes, modification times and so forth.  File names are a potential problem since they can contain  any  character
\par        except  `\\0'  and  `/'.  Unusual characters in file names can do unexpected and often undesirable things to your terminal
\par        (for example, changing the settings of your function keys on some terminals).  Unusual characters are handled differently
\par        by various actions, as described below.
\par 
\par        -print0, -fprint0
\par               Always print the exact filename, unchanged, even if the output is going to a terminal.
\par        -ls, -fls
\par               Unusual  characters  are always escaped.  White space, backslash, and double quote characters are printed using C-
\par               style escaping (for example `\\f', `\\"').  Other unusual characters are  printed  using  an  octal  escape.   Other
\par               printable characters (for -ls and -fls these are the characters between octal 041 and 0176) are printed as-is.
\par        -printf, -fprintf
\par               If  the  output is not going to a terminal, it is printed as-is.  Otherwise, the result depends on which directive
\par               is in use.  The directives %D, %F, %g, %G, %H, %Y, and %y expand to values which are not under control  of  files'
\par               owners,  and so are printed as-is.  The directives %a, %b, %c, %d, %i, %k, %m, %M, %n, %s, %t, %u and %U have val-
\par               ues which are under the control of files' owners but which cannot be used to send arbitrary data to the  terminal,
\par               and  so  these  are printed as-is.  The directives %f, %h, %l, %p and %P are quoted.  This quoting is performed in
\par               the same way as for GNU ls.  This is not the same quoting mechanism as the one used for -ls and -fls.  If you  are
\par               able  to  decide  what format to use for the output of find then it is normally better to use `\\0' as a terminator
\par               than to use newline, as file names can contain white space and newline characters.
\par        -print, -fprint
\par               Quoting is handled in the same way as for -printf and -fprintf.  If you are using find in a script or in a  situa-
\par               tion where the matched files might have arbitrary names, you should consider using -print0 instead of -print.
\par        The -ok and -okdir actions print the current filename as-is.  This may change in a future release.
\par 
\par    OPERATORS
\par        Listed in order of decreasing precedence:
\par        ( expr )
\par               Force  precedence.  Since parentheses are special to the shell, you will normally need to quote them.  Many of the
\par               examples in this manual page use backslashes for this purpose: `\\(...\\)' instead of `(...)'.
\par 
\par        ! expr True if expr is false.  This character will also usually need protection from interpretation by the shell.
\par        -not expr
\par               Same as ! expr, but not POSIX compliant.
\par        expr1 expr2
\par               Two expressions in a row are taken to be joined with an implied "and"; expr2 is not evaluated if expr1 is false.
\par        expr1 -a expr2
\par               Same as expr1 expr2.
\par        expr1 -and expr2
\par               Same as expr1 expr2, but not POSIX compliant.
\par \plain \f1\fs20\cf1        expr1 -o expr2
\par               Or; expr2 is not evaluated if expr1 is true.
\par \plain \f1\fs20        expr1 -or expr2
\par               Same as expr1 -o expr2, but not POSIX compliant.
\par        expr1 , expr2
\par               List; both expr1 and expr2 are always evaluated.  The value of expr1 is discarded; the value of the  list  is  the
\par               value  of expr2. The comma operator can be useful for searching for several different types of thing, but travers-
\par               ing the filesystem hierarchy only once.  The -fprintf action can be used to list the various  matched  items  into
\par               several different output files.
\par 
\par STANDARDS CONFORMANCE
\par        For  closest  compliance  to  the POSIX standard, you should set the POSIXLY_CORRECT environment variable.  The following
\par        options are specified in the POSIX standard (IEEE Std 1003.1, 2003 Edition):
\par        -H     This option is supported.
\par        -L     This option is supported.
\par        -name  This option is supported, but POSIX conformance depends on  the  POSIX  conformance  of  the  system's  fnmatch(3)
\par               library function.  As of findutils-4.2.2, shell metacharacters (`*', `?' or `[]' for example) will match a leading
\par               `.', because IEEE PASC interpretation 126 requires this.   This is a change from previous versions of findutils.
\par        -type  Supported.   POSIX specifies `b', `c', `d', `l', `p', `f' and `s'.  GNU find also  supports  `D',  representing  a
\par               Door, where the OS provides these.
\par        -ok    Supported.   Interpretation of the response is not locale-dependent (see ENVIRONMENT VARIABLES).
\par        -newer Supported.   If  the file specified is a symbolic link, it is always dereferenced.  This is a change from previous
\par               behaviour, which used to take the relevant time from the symbolic link; see the HISTORY section below.
\par        -perm  Supported.  If the POSIXLY_CORRECT environment variable is not set, some mode arguments (for example  +a+x)  which
\par               are not valid in POSIX are supported for backward-compatibility.
\par        Other predicates
\par               The predicates -atime, -ctime, -depth, -group, -links, -mtime, -nogroup, -nouser, -print, -prune, -size, -user and
\par               -xdev are all supported.
\par        The POSIX standard specifies parentheses `(', `)', negation `!' and the `and' and `or' operators ( -a, -o).
\par 
\par        All other options, predicates, expressions and so forth are extensions beyond the POSIX standard.  Many of  these  exten-
\par        sions are not unique to GNU find, however.
\par 
\par        The POSIX standard requires that find detects loops:
\par 
\par               The find utility shall detect infinite loops; that is, entering a previously visited directory that is an ancestor
\par               of the last file encountered. When it detects an infinite loop, find shall write a diagnostic message to  standard
\par               error and shall either recover its position in the hierarchy or terminate.
\par 
\par        GNU  find  complies with these requirements.  The link count of directories which contain entries which are hard links to
\par        an ancestor will often be lower than they otherwise should be.  This can mean that GNU find will sometimes optimise  away
\par        the visiting of a subdirectory which is actually a link to an ancestor.  Since find does not actually enter such a subdi-
\par        rectory, it is allowed to avoid emitting a diagnostic message.  Although this behaviour may be somewhat confusing, it  is
\par        unlikely that anybody actually depends on this behaviour.  If the leaf optimisation has been turned off with -noleaf, the
\par        directory entry will always be examined and the diagnostic message will be issued  where  it  is  appropriate.   Symbolic
\par        links  cannot  be used to create filesystem cycles as such, but if the -L option or the -follow option is in use, a diag-
\par        nostic message is issued when find encounters a loop of symbolic links.  As with loops containing hard  links,  the  leaf
\par        optimisation will often mean that find knows that it doesn't need to call stat() or chdir() on the symbolic link, so this
\par        diagnostic is frequently not necessary.
\par 
\par        The -d option is supported for compatibility with various BSD systems, but you  should  use  the  POSIX-compliant  option
\par        -depth instead.
\par 
\par        The POSIXLY_CORRECT environment variable does not affect the behaviour of the -regex or -iregex tests because those tests
\par        aren't specified in the POSIX standard.
\par 
\par ENVIRONMENT VARIABLES
\par        LANG   Provides a default value for the internationalization variables that are unset or null.
\par 
\par 
\par        LC_ALL If set to a non-empty string value, override the values of all the other internationalization variables.
\par 
\par 
\par        LC_COLLATE
\par               The POSIX standard specifies that this variable affects the pattern matching to be  used  for  the  -name  option.
\par               GNU find uses the fnmatch(3) library function, and so support for `LC_COLLATE' depends on the system library.
\par 
\par 
\par               POSIX  also specifies that the `LC_COLLATE' environment variable affects the interpretation of the user's response
\par               to the query issued by -ok', but this is not the case for GNU find.
\par 
\par 
\par        LC_CTYPE
\par               This variable affects the treatment of character classes used with the -name  test,  if  the  system's  fnmatch(3)
\par               library function supports this.   It has no effect on the behaviour of the -ok expression.
\par 
\par 
\par        LC_MESSAGES
\par               Determines the locale to be used for internationalised messages.
\par 
\par 
\par        NLSPATH
\par               Determines the location of the internationalisation message catalogues.
\par 
\par 
\par        PATH   Affects the directories which are searched to find the executables invoked by -exec, -execdir, -ok and -okdir.
\par 
\par 
\par        POSIXLY_CORRECT
\par               Determines the block size used by -ls and -fls.  If POSIXLY_CORRECT is set, blocks are units of 512 bytes.  Other-
\par               wise they are units of 1024 bytes.
\par 
\par               Setting this variable also turns off warning messages  (that  is,  implies  -nowarn)  by  default,  because  POSIX
\par               requires  that  apart from the output for -ok, all messages printed on stderr are diagnositcs and must result in a
\par               non-zero exit status.
\par 
\par               When POSIXLY_CORRECT is not set, -perm +zzz is treated just like -perm /zzz if +zzz is not a valid symbolic  mode.
\par               When POSIXLY_CORRECT is set, such constructs are treated as an error.
\par 
\par 
\par        TZ     Affects the time zone used for some of the time-related format directives of -printf and -fprintf.
\par 
\par \plain \f1\b\fs20 EXAMPLES
\par \plain \f1\fs20  \plain \f1\fs20\cf1       find /tmp -name core -type f -print | xargs /bin/rm -f
\par \plain \f1\fs20 
\par        Find  files named core in or below the directory /tmp and delete them.  Note that this will work incorrectly if there are
\par        any filenames containing newlines, single or double quotes, or spaces.
\par 
\par        find /tmp -name core -type f -print0 | xargs -0 /bin/rm -f
\par 
\par        Find files named core in or below the directory /tmp and delete them, processing filenames in such a  way  that  file  or
\par        directory  names  containing  single  or  double  quotes, spaces or newlines are correctly handled.  The -name test comes
\par        before the -type test in order to avoid having to call stat(2) on every file.
\par 
\par 
\par        find . -type f -exec file '\{\}' \\;
\par 
\par        Runs `file' on every file in or below the current directory.  Notice that the braces are enclosed in single  quote  marks
\par        to  protect  them  from interpretation as shell script punctuation.  The semicolon is similarly protected by the use of a
\par        backslash, though single quotes could have been used in that case also.
\par 
\par 
\par        find / \\
\par        \\( -perm -4000 -fprintf /root/suid.txt %#m %u %p\\n \\) , \\
\par        \\( -size +100M -fprintf /root/big.txt %-10s %p\\n \\)
\par 
\par        Traverse the filesystem just once, listing setuid  files  and  directories  into  /root/suid.txt  and  large  files  into
\par        /root/big.txt.
\par 
\par 
\par        find $HOME -mtime 0
\par 
\par        Search  for files in your home directory which have been modified in the last twenty-four hours.  This command works this
\par        way because the time since each file was last modified is divided by 24 hours and any remainder is discarded.  That means
\par        that to match -mtime 0, a file will have to have a modification in the past which is less than 24 hours ago.
\par 
\par 
\par        find /sbin /usr/sbin -executable \\! -readable -print
\par 
\par        Search for files which are executable but not readable.
\par 
\par 
\par        find . -perm 664
\par 
\par        Search  for files which have read and write permission for their owner, and group, but which other users can read but not
\par        write to.  Files which meet these criteria but have other permissions bits set (for example if someone  can  execute  the
\par        file) will not be matched.
\par 
\par 
\par        find . -perm -664
\par 
\par        Search  for files which have read and write permission for their owner and group, and which other users can read, without
\par        regard to the presence of any extra permission bits (for example the executable bit).  This will match a file  which  has
\par        mode 0777, for example.
\par 
\par 
\par        find . -perm /222
\par 
\par        Search for files which are writable by somebody (their owner, or their group, or anybody else).
\par 
\par 
\par        find . -perm /220
\par        find . -perm /u+w,g+w
\par        find . -perm /u=w,g=w
\par 
\par        All  three of these commands do the same thing, but the first one uses the octal representation of the file mode, and the
\par        other two use the symbolic form.  These commands all search for files which are writable by either their owner  or  their
\par        group.  The files don't have to be writable by both the owner and group to be matched; either will do.
\par 
\par 
\par        find . -perm -220
\par        find . -perm -g+w,u+w
\par 
\par        Both these commands do the same thing; search for files which are writable by both their owner and their group.
\par 
\par 
\par        find . -perm -444 -perm /222 ! -perm /111
\par        find . -perm -a+r -perm /a+w ! -perm /a+x
\par 
\par        These  two  commands both search for files that are readable for everybody ( -perm -444 or -perm -a+r), have at least one
\par        write bit set ( -perm /222 or -perm /a+w) but are not executable for anybody ( ! -perm /111  and  !  -perm  /a+x  respec-
\par        tively).
\par 
\par 
\par        cd /source-dir
\par        find . -name .snapshot -prune -o \\( \\! -name *~ -print0 \\)|
\par        cpio -pmd0 /dest-dir
\par 
\par        This  command  copies  the  contents  of  /source-dir  to /dest-dir, but omits files and directories named .snapshot (and
\par        anything in them).  It also omits files or directories whose name ends in ~,  but  not  their  contents.   The  construct
\par        -prune -o \\( ... -print0 \\) is quite common.  The idea here is that the expression before -prune matches things which are
\par        to be pruned.  However, the -prune action itself returns true, so the following -o ensures that the right  hand  side  is
\par        evaluated  only  for  those directories which didn't get pruned (the contents of the pruned directories are not even vis-
\par        ited, so their contents are irrelevant).  The expression on the right hand side of the -o  is  in  parentheses  only  for
\par        clarity.   It  emphasises  that  the  -print0 action takes place only for things that didn't have -prune applied to them.
\par        Because the default `and' condition between tests binds more tightly than -o, this is the default anyway, but the  paren-
\par        theses help to show what is going on.
\par 
\par 
\par EXIT STATUS
\par        find  exits with status 0 if all files are processed successfully, greater than 0 if errors occur.   This is deliberately
\par        a very broad description, but if the return value is non-zero, you should not rely on the correctness of the  results  of
\par        find.
\par 
\par 
\par SEE ALSO
\par        locate(1), locatedb(5), updatedb(1), xargs(1), chmod(1), fnmatch(3), regex(7), stat(2), lstat(2), ls(1), printf(3), strf-
\par        time(3), ctime(3), Finding Files (on-line in Info, or printed).
\par 
\par HISTORY
\par        As of findutils-4.2.2, shell metacharacters (`*', `?' or `[]' for example) used in filename patterns will match a leading
\par        `.', because IEEE POSIX interpretation 126 requires this.
\par 
\par        The  syntax  -perm +MODE was deprecated in findutils-4.2.21, in favour of -perm /MODE.  As of findutils-4.3.3, -perm /000
\par        now matches all files instead of none.
\par 
\par        Nanosecond-resolution timestamps were implemented in findutils-4.3.3.
\par 
\par        As of findutils-4.3.11, the -delete action sets find's exit status to a nonzero value when it fails.  However, find  will
\par        not exit immediately.  Previously, find's exit status was unaffected by the failure of -delete.
\par 
\par        Feature                Added in   Also occurs in
\par        -newerXY               4.3.3      BSD
\par        -D                     4.3.1
\par        -O                     4.3.1
\par        -readable              4.3.0
\par        -writable              4.3.0
\par        -executable            4.3.0
\par        -regextype             4.2.24
\par        -exec ... +            4.2.12     POSIX
\par        -execdir               4.2.12     BSD
\par        -okdir                 4.2.12
\par        -samefile              4.2.11
\par        -H                     4.2.5      POSIX
\par        -L                     4.2.5      POSIX
\par        -P                     4.2.5      BSD
\par        -delete                4.2.3
\par        -quit                  4.2.3
\par        -d                     4.2.3      BSD
\par        -wholename             4.2.0
\par        -iwholename            4.2.0
\par        -ignore_readdir_race   4.2.0
\par        -fls                   4.0
\par        -ilname                3.8
\par        -iname                 3.8
\par        -ipath                 3.8
\par        -iregex                3.8
\par 
\par NON-BUGS
\par        $ find . -name *.c -print
\par        find: paths must precede expression
\par        Usage: find [-H] [-L] [-P] [-Olevel] [-D help|tree|search|stat|rates|opt|exec] [path...] [expression]
\par 
\par        This happens because *.c has been expanded by the shell resulting in find actually receiving a command line like this:
\par 
\par        find . -name bigram.c code.c frcode.c locate.c -print
\par 
\par        That  command is of course not going to work.  Instead of doing things this way, you should enclose the pattern in quotes
\par        or escape the wildcard:
\par        $ find . -name \\*.c -print
\par 
\par 
\par BUGS
\par        There are security problems inherent in the behaviour that the POSIX standard specifies for find, which therefore  cannot
\par        be fixed.  For example, the -exec action is inherently insecure, and -execdir should be used instead.  Please see Finding
\par        Files for more information.
\par 
\par        The environment variable LC_COLLATE has no effect on the -ok action.
\par 
\par        The best way to report a bug is to use the form at http://savannah.gnu.org/bugs/?group=findutils.  The reason for this is
\par        that  you  will then be able to track progress in fixing the problem.   Other comments about find(1) and about the findu-
\par        tils package in general can be sent to the bug-findutils mailing list.  To  join  the  list,  send  email  to  bug-findu-
\par        tils-request@gnu.org.\par}