{\rtf1\fbidis\ansi\ansicpg0\uc1\deff0\deflang0\deflangfe0{\fonttbl{\f0\fnil \'cb\'ce\'cc\'e5;}{\f1\fnil \'ce\'a2\'c8\'ed\'d1\'c5\'ba\'da;}{\f2\fnil\fcharset134 \'cb\'ce\'cc\'e5;}{\f3\fnil Arial;}{\f4\fnil\fcharset2 Symbol;}{\f5\fnil\fcharset0 Courier New;}}{\colortbl;\red0\green0\blue255;\red0\green0\blue0;\red255\green255\blue255;}{\*\listtable{\list\listtemplateid257083047\listsimple1
{\listlevel\levelnfc23\leveljc0\li720\fi-360\jclisttab\tx720{\leveltext\'00;}{\levelnumbers;}\f3\fs24}
\listid1884062023}
{\list\listtemplateid1919674474\listsimple1
{\listlevel\levelnfc23\leveljc0\li720\fi-360\jclisttab\tx720{\leveltext\'00;}{\levelnumbers;}\f3\fs24}
\listid2068493846}
{\list\listtemplateid1528147061\listsimple1
{\listlevel\levelnfc23\leveljc0\li720\fi-360\jclisttab\tx720{\leveltext\'00;}{\levelnumbers;}\f3\fs24}
\listid134821454}
{\list\listtemplateid245533064
{\listlevel\levelnfc23\leveljc0\li720\fi-360\jclisttab\tx720{\leveltext\'01\uc2\u183 \'a1\'a4\uc1;}{\levelnumbers;}\f4\fs24\lang1024}
{\listlevel\levelnfc23\leveljc0\li1080\fi-360\jclisttab\tx1080{\leveltext\'01o;}{\levelnumbers;}\f5\fs24}
{\listlevel\levelnfc23\leveljc0\li1080\fi-360\jclisttab\tx1080{\leveltext\'01o;}{\levelnumbers;}\f5\fs24}
{\listlevel\levelnfc23\leveljc0\li1080\fi-360\jclisttab\tx1080{\leveltext\'01o;}{\levelnumbers;}\f5\fs24}
{\listlevel\levelnfc23\leveljc0\li1080\fi-360\jclisttab\tx1080{\leveltext\'01o;}{\levelnumbers;}\f5\fs24}
{\listlevel\levelnfc23\leveljc0\li1080\fi-360\jclisttab\tx1080{\leveltext\'01o;}{\levelnumbers;}\f5\fs24}
{\listlevel\levelnfc23\leveljc0\li1080\fi-360\jclisttab\tx1080{\leveltext\'01o;}{\levelnumbers;}\f5\fs24}
{\listlevel\levelnfc23\leveljc0\li1080\fi-360\jclisttab\tx1080{\leveltext\'01o;}{\levelnumbers;}\f5\fs24}
{\listlevel\levelnfc23\leveljc0\li1080\fi-360\jclisttab\tx1080{\leveltext\'01o;}{\levelnumbers;}\f5\fs24}
\listid744444845}
{\list\listtemplateid242096227\listsimple1
{\listlevel\levelnfc23\leveljc0\li720\fi-360\jclisttab\tx720{\leveltext\'00;}{\levelnumbers;}\f3\fs24}
\listid1876560371}
{\list\listtemplateid268977094
{\listlevel\levelnfc23\leveljc0\li720\fi-360\jclisttab\tx720{\leveltext\'01\uc2\u183 \'a1\'a4\uc1;}{\levelnumbers;}\f4\fs24\lang1024}
{\listlevel\levelnfc23\leveljc0\li1080\fi-360\jclisttab\tx1080{\leveltext\'01o;}{\levelnumbers;}\f5\fs24}
{\listlevel\levelnfc23\leveljc0\li1080\fi-360\jclisttab\tx1080{\leveltext\'01o;}{\levelnumbers;}\f5\fs24}
{\listlevel\levelnfc23\leveljc0\li1080\fi-360\jclisttab\tx1080{\leveltext\'01o;}{\levelnumbers;}\f5\fs24}
{\listlevel\levelnfc23\leveljc0\li1080\fi-360\jclisttab\tx1080{\leveltext\'01o;}{\levelnumbers;}\f5\fs24}
{\listlevel\levelnfc23\leveljc0\li1080\fi-360\jclisttab\tx1080{\leveltext\'01o;}{\levelnumbers;}\f5\fs24}
{\listlevel\levelnfc23\leveljc0\li1080\fi-360\jclisttab\tx1080{\leveltext\'01o;}{\levelnumbers;}\f5\fs24}
{\listlevel\levelnfc23\leveljc0\li1080\fi-360\jclisttab\tx1080{\leveltext\'01o;}{\levelnumbers;}\f5\fs24}
{\listlevel\levelnfc23\leveljc0\li1080\fi-360\jclisttab\tx1080{\leveltext\'01o;}{\levelnumbers;}\f5\fs24}
\listid1767108322}
{\list\listtemplateid1760360561\listsimple1
{\listlevel\levelnfc23\leveljc0\li720\fi-360\jclisttab\tx720{\leveltext\'00;}{\levelnumbers;}\f3\fs24}
\listid273392186}
}
{\*\listoverridetable
{\listoverride\listid1884062023\listoverridecount0\ls1}
{\listoverride\listid2068493846\listoverridecount0\ls2}
{\listoverride\listid134821454\listoverridecount0\ls3}
{\listoverride\listid744444845\listoverridecount0\ls4}
{\listoverride\listid1876560371\listoverridecount0\ls5}
{\listoverride\listid1767108322\listoverridecount0\ls6}
{\listoverride\listid273392186\listoverridecount0\ls7}
}


\pard\fi0\li0\qc\ri0\sb0\sa0\itap0 \plain \f2\b\lang2052\fs24\cf2 /etc/init.d/functions.new 
\par \pard\fi0\li0\ql\ri0\sb0\sa0\itap0 
\par \plain \f1\fs20 # -*-Shell-script-*-
\par #
\par # functions     This file contains functions to be used by most or all
\par #               shell scripts in the /etc/init.d directory.
\par #
\par 
\par TEXTDOMAIN=initscripts
\par 
\par # Make sure umask is sane
\par umask 022
\par 
\par # Set up a default search path.
\par PATH="/sbin:/usr/sbin:/bin:/usr/bin"
\par export PATH
\par 
\par # Get a sane screen width
\par [ -z "$\{COLUMNS:-\}" ] && COLUMNS=80
\par 
\par [ -z "$\{CONSOLETYPE:-\}" ] && CONSOLETYPE="$(/sbin/consoletype)"
\par 
\par if [ -f /etc/sysconfig/i18n -a -z "$\{NOLOCALE:-\}" -a -z "$\{LANGSH_SOURCED:-\}" ] ; then
\par   . /etc/profile.d/lang.sh 2>/dev/null
\par   # avoid propagating LANGSH_SOURCED any further
\par   unset LANGSH_SOURCED
\par fi
\par 
\par # Read in our configuration
\par if [ -z "$\{BOOTUP:-\}" ]; then
\par   if [ -f /etc/sysconfig/init ]; then
\par       . /etc/sysconfig/init
\par   else
\par     # This all seem confusing? Look in /etc/sysconfig/init,
\par     # or in /usr/doc/initscripts-*/sysconfig.txt
\par     BOOTUP=color
\par     RES_COL=60
\par     MOVE_TO_COL="echo -en \\\\033[$\{RES_COL\}G"
\par     SETCOLOR_SUCCESS="echo -en \\\\033[1;32m"
\par     SETCOLOR_FAILURE="echo -en \\\\033[1;31m"
\par     SETCOLOR_WARNING="echo -en \\\\033[1;33m"
\par     SETCOLOR_NORMAL="echo -en \\\\033[0;39m"
\par     LOGLEVEL=1
\par   fi
\par   if [ "$CONSOLETYPE" = "serial" ]; then
\par       BOOTUP=serial
\par       MOVE_TO_COL=
\par       SETCOLOR_SUCCESS=
\par       SETCOLOR_FAILURE=
\par       SETCOLOR_WARNING=
\par       SETCOLOR_NORMAL=
\par   fi
\par fi
\par 
\par # Interpret escape sequences in an fstab entry
\par \plain \f1\fs20\cf1 fstab_decode_str\plain \f1\fs20 () \{
\par         fstab-decode echo "$1"
\par \}
\par 
\par # Check if $pid (could be plural) are running
\par \plain \f1\fs20\cf1 checkpid\plain \f1\fs20 () \{
\par         local i
\par 
\par         for i in $* ; do
\par                 [ -d "/proc/$i" ] && return 0
\par         done
\par         return 1
\par \}
\par 
\par \plain \f1\fs20\cf1 __readlink\plain \f1\fs20 () \{
\par     ls -bl "$@" 2>/dev/null| awk '\{ print $NF \}'
\par \}
\par 
\par \plain \f1\fs20\cf1 __fgrep\plain \f1\fs20 () \{
\par     s=$1
\par     f=$2
\par     while read line; do
\par         if strstr "$line" "$s"; then
\par             echo $line
\par             return 0
\par         fi
\par     done < $f
\par     return 1
\par \}
\par 
\par # __umount_loop awk_program fstab_file first_msg retry_msg umount_args
\par # awk_program should process fstab_file and return a list of fstab-encoded
\par # paths; it doesn't have to handle comments in fstab_file.
\par \plain \f1\fs20\cf1 __umount_loop\plain \f1\fs20 () \{
\par         local remaining sig=
\par         local retry=3 count
\par 
\par         remaining=$(LC_ALL=C awk "/^#/ \{next\} $1" "$2" | sort -r)
\par         while [ -n "$remaining" -a "$retry" -gt 0 ]; do
\par                 if [ "$retry" -eq 3 ]; then
\par                         action "$3" fstab-decode umount $5 $remaining
\par                 else
\par                         action "$4" fstab-decode umount $5 $remaining
\par                 fi
\par                 count=4
\par                 remaining=$(LC_ALL=C awk "/^#/ \{next\} $1" "$2" | sort -r)
\par                 while [ "$count" -gt 0 ]; do
\par                         [ -z "$remaining" ] && break
\par                         count=$(($count-1))
\par                         usleep 500000
\par                         remaining=$(LC_ALL=C awk "/^#/ \{next\} $1" "$2" | sort -r)
\par                 done
\par                 [ -z "$remaining" ] && break
\par                 fstab-decode /sbin/fuser -k -m $sig $remaining >/dev/null
\par                 sleep 3
\par                 retry=$(($retry -1))
\par                 sig=-9
\par         done
\par \}
\par 
\par # Similar to __umount loop above, specialized for loopback devices
\par \plain \f1\fs20\cf1 __umount_loopback_loop\plain \f1\fs20 () \{
\par         local remaining devremaining sig=
\par         local retry=3
\par 
\par         remaining=$(awk '$1 ~ /^\\/dev\\/loop/ && $2 != "/" \{print $2\}' /proc/mounts)
\par         devremaining=$(awk '$1 ~ /^\\/dev\\/loop/ && $2 != "/" \{print $1\}' /proc/mounts)
\par         while [ -n "$remaining" -a "$retry" -gt 0 ]; do
\par                 if [ "$retry" -eq 3 ]; then
\par                         action $"Unmounting loopback filesystems: " \\
\par                                 fstab-decode umount $remaining
\par                 else
\par                         action $"Unmounting loopback filesystems (retry):" \\
\par                                 fstab-decode umount $remaining
\par                 fi
\par                 for dev in $devremaining ; do
\par                         losetup $dev > /dev/null 2>&1 && \\
\par                                 action $"Detaching loopback device $dev: " \\
\par                                 losetup -d $dev
\par                 done
\par                 remaining=$(awk '$1 ~ /^\\/dev\\/loop/ && $2 != "/" \{print $2\}' /proc/mounts)
\par                 devremaining=$(awk '$1 ~ /^\\/dev\\/loop/ && $2 != "/" \{print $1\}' /proc/mounts)
\par                 [ -z "$remaining" ] && break
\par                 fstab-decode /sbin/fuser -k -m $sig $remaining >/dev/null
\par                 sleep 3
\par                 retry=$(($retry -1))
\par                 sig=-9
\par         done
\par \}
\par 
\par # __proc_pids \{program\} [pidfile]
\par # Set $pid to pids from /var/run* for \{program\}.  $pid should be declared
\par # local in the caller.
\par # Returns LSB exit code for the 'status' action.
\par \plain \f1\fs20\cf1 __pids_var_run\plain \f1\fs20 () \{
\par         local base=$\{1##*/\}
\par         local pid_file=$\{2:-/var/run/$base.pid\}
\par 
\par         pid=
\par         if [ -f "$pid_file" ] ; then
\par                 local line p
\par 
\par                 [ ! -r "$pid_file" ] && return 4 # "user had insufficient privilege"
\par                 while : ; do
\par                         read line
\par                         [ -z "$line" ] && break
\par                         for p in $line ; do
\par                                 [ -z "$\{p//[0-9]/\}" -a -d "/proc/$p" ] && pid="$pid $p"
\par                         done
\par                 done < "$pid_file"
\par 
\par                 if [ -n "$pid" ]; then
\par                         return 0
\par                 fi
\par                 return 1 # "Program is dead and /var/run pid file exists"
\par         fi
\par         return 3 # "Program is not running"
\par \}
\par 
\par # Output PIDs of matching processes, found using pidof
\par __pids_pidof() \{
\par         pidof -c -o $$ -o $PPID -o %PPID -x "$1" || \\
\par                 pidof -c -o $$ -o $PPID -o %PPID -x "$\{1##*/\}"
\par \}
\par 
\par 
\par \plain \f1\fs20\cf1 # A function to start a program.
\par daemon\plain \f1\fs20 () \{
\par         # Test syntax.
\par         local gotbase= force= nicelevel corelimit
\par         local pid base= user= nice= bg= pid_file=
\par         local cgroup=
\par         nicelevel=0
\par         while [ "$1" != "$\{1##[-+]\}" ]; do
\par           case $1 in
\par             '')    echo $"$0: Usage: daemon [+/-nicelevel] \{program\}"
\par                    return 1;;
\par             --check)
\par                    base=$2
\par                    gotbase="yes"
\par                    shift 2
\par                    ;;
\par             --check=?*)
\par                    base=$\{1#--check=\}
\par                    gotbase="yes"
\par                    shift
\par                    ;;
\par             --user)
\par                    user=$2
\par                    shift 2
\par                    ;;
\par             --user=?*)
\par                    user=$\{1#--user=\}
\par                    shift
\par                    ;;
\par             --pidfile)
\par                    pid_file=$2
\par                    shift 2
\par                    ;;
\par             --pidfile=?*)
\par                    pid_file=$\{1#--pidfile=\}
\par                    shift
\par                    ;;
\par             --force)
\par                    force="force"
\par                    shift
\par                    ;;
\par             [-+][0-9]*)
\par                    nice="nice -n $1"
\par                    shift
\par                    ;;
\par             *)     echo $"$0: Usage: daemon [+/-nicelevel] \{program\}"
\par                    return 1;;
\par           esac
\par         done
\par 
\par         # Save basename.
\par         [ -z "$gotbase" ] && base=$\{1##*/\}
\par 
\par         # See if it's already running. Look *only* at the pid file.
\par         __pids_var_run "$base" "$pid_file"
\par 
\par         [ -n "$pid" -a -z "$force" ] && return
\par 
\par         # make sure it doesn't core dump anywhere unless requested
\par         corelimit="ulimit -S -c $\{DAEMON_COREFILE_LIMIT:-0\}"
\par 
\par         # if they set NICELEVEL in /etc/sysconfig/foo, honor it
\par         [ -n "$\{NICELEVEL:-\}" ] && nice="nice -n $NICELEVEL"
\par 
\par         # if they set CGROUP_DAEMON in /etc/sysconfig/foo, honor it
\par         if [ -n "$\{CGROUP_DAEMON\}" ]; then
\par                 if [ ! -x /bin/cgexec ]; then
\par                         echo -n "Cgroups not installed"; warning
\par                         echo
\par                 else
\par                         cgroup="/bin/cgexec";
\par                         for i in $CGROUP_DAEMON; do
\par                                 cgroup="$cgroup -g $i";
\par                         done
\par                 fi
\par         fi
\par 
\par         # Echo daemon
\par         [ "$\{BOOTUP:-\}" = "verbose" -a -z "$\{LSB:-\}" ] && echo -n " $base"
\par 
\par         # And start it up.
\par         if [ -z "$user" ]; then
\par            $cgroup $nice /bin/bash -c "$corelimit >/dev/null 2>&1 ; $*"
\par         else
\par            $cgroup $nice runuser -s /bin/bash $user -c "$corelimit >/dev/null 2>&1 ; $*"
\par         fi
\par 
\par         [ "$?" -eq 0 ] && success $"$base startup" || failure $"$base startup"
\par \}
\par 
\par \plain \f1\fs20\cf1 # A function to stop a program.
\par \plain \f1\fs20 killproc() \{
\par         local RC killlevel= base pid pid_file= delay
\par 
\par         RC=0; delay=3
\par         # Test syntax.
\par         if [ "$#" -eq 0 ]; then
\par                 echo $"Usage: killproc [-p pidfile] [ -d delay] \{program\} [-signal]"
\par                 return 1
\par         fi
\par         if [ "$1" = "-p" ]; then
\par                 pid_file=$2
\par                 shift 2
\par         fi
\par         if [ "$1" = "-d" ]; then
\par                 delay=$2
\par                 shift 2
\par         fi
\par         
\par 
\par         # check for second arg to be kill level
\par         [ -n "$\{2:-\}" ] && killlevel=$2
\par 
\par         # Save basename.
\par         base=$\{1##*/\}
\par 
\par         # Find pid.
\par         __pids_var_run "$1" "$pid_file"
\par         RC=$?
\par         if [ -z "$pid" ]; then
\par                 if [ -z "$pid_file" ]; then
\par                         pid="$(__pids_pidof "$1")"
\par                 else
\par                         [ "$RC" = "4" ] && \{ failure $"$base shutdown" ; return $RC ;\}
\par                 fi
\par         fi
\par 
\par         # Kill it.
\par         if [ -n "$pid" ] ; then
\par                 [ "$BOOTUP" = "verbose" -a -z "$\{LSB:-\}" ] && echo -n "$base "
\par                 if [ -z "$killlevel" ] ; then
\par                        if checkpid $pid 2>&1; then
\par                            # TERM first, then KILL if not dead
\par                            kill -TERM $pid >/dev/null 2>&1
\par                            usleep 100000
\par                            if checkpid $pid && sleep 1 &&
\par                               checkpid $pid && sleep $delay &&
\par                               checkpid $pid ; then
\par                                 kill -KILL $pid >/dev/null 2>&1
\par                                 usleep 100000
\par                            fi
\par                         fi
\par                         checkpid $pid
\par                         RC=$?
\par                         [ "$RC" -eq 0 ] && failure $"$base shutdown" || success $"$base shutdown"
\par                         RC=$((! $RC))
\par                 # use specified level only
\par                 else
\par                         if checkpid $pid; then
\par                                 kill $killlevel $pid >/dev/null 2>&1
\par                                 RC=$?
\par                                 [ "$RC" -eq 0 ] && success $"$base $killlevel" || failure $"$base $killlevel"
\par                         elif [ -n "$\{LSB:-\}" ]; then
\par                                 RC=7 # Program is not running
\par                         fi
\par                 fi
\par         else
\par                 if [ -n "$\{LSB:-\}" -a -n "$killlevel" ]; then
\par                         RC=7 # Program is not running
\par                 else
\par                         failure $"$base shutdown"
\par                         RC=0
\par                 fi
\par         fi
\par 
\par         # Remove pid file if any.
\par         if [ -z "$killlevel" ]; then
\par             rm -f "$\{pid_file:-/var/run/$base.pid\}"
\par         fi
\par         return $RC
\par \}
\par \plain \f1\fs20\cf1 
\par # A function to find the pid of a program. Looks *only* at the pidfile
\par \plain \f1\fs20 pidfileofproc() \{
\par         local pid
\par 
\par         # Test syntax.
\par         if [ "$#" = 0 ] ; then
\par                 echo $"Usage: pidfileofproc \{program\}"
\par                 return 1
\par         fi
\par 
\par         __pids_var_run "$1"
\par         [ -n "$pid" ] && echo $pid
\par         return 0
\par \}
\par 
\par \plain \f1\fs20\cf1 # A function to find the pid of a program.
\par \plain \f1\fs20 pidofproc() \{
\par         local RC pid pid_file=
\par 
\par         # Test syntax.
\par         if [ "$#" = 0 ]; then
\par                 echo $"Usage: pidofproc [-p pidfile] \{program\}"
\par                 return 1
\par         fi
\par         if [ "$1" = "-p" ]; then
\par                 pid_file=$2
\par                 shift 2
\par         fi
\par         fail_code=3 # "Program is not running"
\par 
\par         # First try "/var/run/*.pid" files
\par         __pids_var_run "$1" "$pid_file"
\par         RC=$?
\par         if [ -n "$pid" ]; then
\par                 echo $pid
\par                 return 0
\par         fi
\par 
\par         [ -n "$pid_file" ] && return $RC
\par         __pids_pidof "$1" || return $RC
\par \}
\par 
\par \plain \f1\fs20\cf1 status() \{
\par \plain \f1\fs20         local base pid lock_file= pid_file=
\par 
\par         # Test syntax.
\par         if [ "$#" = 0 ] ; then
\par                 echo $"Usage: status [-p pidfile] \{program\}"
\par                 return 1
\par         fi
\par         if [ "$1" = "-p" ]; then
\par                 pid_file=$2
\par                 shift 2
\par         fi
\par         if [ "$1" = "-l" ]; then
\par                 lock_file=$2
\par                 shift 2
\par         fi
\par         base=$\{1##*/\}
\par 
\par         # First try "pidof"
\par         __pids_var_run "$1" "$pid_file"
\par         RC=$?
\par         if [ -z "$pid_file" -a -z "$pid" ]; then
\par                 pid="$(__pids_pidof "$1")"
\par         fi
\par         if [ -n "$pid" ]; then
\par                 echo $"$\{base\} (pid $pid) is running..."
\par                 return 0
\par         fi
\par 
\par         case "$RC" in
\par                 0)
\par                         echo $"$\{base\} (pid $pid) is running..."
\par                         return 0
\par                         ;;
\par                 1)
\par                         echo $"$\{base\} dead but pid file exists"
\par                         return 1
\par                         ;;
\par                 4)
\par                         echo $"$\{base\} status unknown due to insufficient privileges."
\par                         return 4
\par                         ;;
\par         esac
\par         if [ -z "$\{lock_file\}" ]; then
\par                 lock_file=$\{base\}
\par         fi
\par         # See if /var/lock/subsys/$\{lock_file\} exists
\par         if [ -f /var/lock/subsys/$\{lock_file\} ]; then
\par                 echo $"$\{base\} dead but subsys locked"
\par                 return 2
\par         fi
\par         echo $"$\{base\} is stopped"
\par         return 3
\par \}
\par \plain \f1\fs20\cf1 
\par echo_success() \{
\par \plain \f1\fs20   [ "$BOOTUP" = "color" ] && $MOVE_TO_COL
\par   echo -n "["
\par   [ "$BOOTUP" = "color" ] && $SETCOLOR_SUCCESS
\par   echo -n $"  OK  "
\par   [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
\par   echo -n "]"
\par   echo -ne "\\r"
\par   return 0
\par \}
\par 
\par echo_failure() \{
\par   [ "$BOOTUP" = "color" ] && $MOVE_TO_COL
\par   echo -n "["
\par   [ "$BOOTUP" = "color" ] && $SETCOLOR_FAILURE
\par   echo -n $"FAILED"
\par   [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
\par   echo -n "]"
\par   echo -ne "\\r"
\par   return 1
\par \}
\par 
\par \plain \f1\fs20\cf1 echo_passed() \{
\par \plain \f1\fs20   [ "$BOOTUP" = "color" ] && $MOVE_TO_COL
\par   echo -n "["
\par   [ "$BOOTUP" = "color" ] && $SETCOLOR_WARNING
\par   echo -n $"PASSED"
\par   [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
\par   echo -n "]"
\par   echo -ne "\\r"
\par   return 1
\par \}
\par \plain \f1\fs20\cf1 
\par echo_warning() \{
\par \plain \f1\fs20   [ "$BOOTUP" = "color" ] && $MOVE_TO_COL
\par   echo -n "["
\par   [ "$BOOTUP" = "color" ] && $SETCOLOR_WARNING
\par   echo -n $"WARNING"
\par   [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
\par   echo -n "]"
\par   echo -ne "\\r"
\par   return 1
\par \}
\par 
\par # Inform the graphical boot of our current state
\par update_boot_stage() \{
\par   if [ -x /usr/bin/plymouth ]; then
\par       /usr/bin/plymouth --update="$1"
\par   fi
\par   return 0
\par \}
\par 
\par \plain \f1\fs20\cf1 # Log that something succeeded
\par \plain \f1\fs20 success() \{
\par   [ "$BOOTUP" != "verbose" -a -z "$\{LSB:-\}" ] && echo_success
\par   return 0
\par \}
\par 
\par \plain \f1\fs20\cf1 # Log that something failed
\par \plain \f1\fs20 failure() \{
\par   local rc=$?
\par   [ "$BOOTUP" != "verbose" -a -z "$\{LSB:-\}" ] && echo_failure
\par   [ -x /usr/bin/plymouth ] && /usr/bin/plymouth --details
\par   return $rc
\par \}
\par \plain \f1\fs20\cf1 
\par # Log that something passed, but may have had errors. Useful for fsck
\par \plain \f1\fs20 passed() \{
\par   local rc=$?
\par   [ "$BOOTUP" != "verbose" -a -z "$\{LSB:-\}" ] && echo_passed
\par   return $rc
\par \}  
\par 
\par \plain \f1\fs20\cf1 # Log a warning
\par \plain \f1\fs20 warning() \{
\par   local rc=$?
\par   [ "$BOOTUP" != "verbose" -a -z "$\{LSB:-\}" ] && echo_warning
\par   return $rc
\par \}  
\par \plain \f1\fs20\cf1 
\par # Run some action. Log its output.
\par \plain \f1\fs20 action() \{
\par   local STRING rc
\par 
\par   STRING=$1
\par   echo -n "$STRING "
\par   shift
\par   "$@" && success $"$STRING" || failure $"$STRING"
\par   rc=$?
\par   echo
\par   return $rc
\par \}
\par 
\par \plain \f1\fs20\cf1 # returns OK if $1 contains $2
\par \plain \f1\fs20 strstr() \{
\par   [ "$\{1#*$2*\}" = "$1" ] && return 1
\par   return 0
\par \}
\par 
\par \plain \f1\fs20\cf1 # Confirm whether we really want to run this service
\par \plain \f1\fs20 confirm() \{
\par   [ -x /usr/bin/plymouth ] && /usr/bin/plymouth --hide-splash
\par   while : ; do 
\par       echo -n $"Start service $1 (Y)es/(N)o/(C)ontinue? [Y] "
\par       read answer
\par       if strstr $"yY" "$answer" || [ "$answer" = "" ] ; then
\par          return 0
\par       elif strstr $"cC" "$answer" ; then
\par          rm -f /var/run/confirm
\par          [ -x /usr/bin/plymouth ] && /usr/bin/plymouth --show-splash
\par          return 2
\par       elif strstr $"nN" "$answer" ; then
\par          return 1
\par       fi
\par   done
\par \}
\par \plain \f1\fs20\cf1 
\par # resolve a device node to its major:minor numbers in decimal or hex
\par \plain \f1\fs20 get_numeric_dev() \{
\par (
\par     fmt="%d:%d"
\par     if [ "$1" == "hex" ]; then
\par         fmt="%x:%x"
\par     fi
\par     ls -lH "$2" | awk '\{ sub(/,/, "", $5); printf("'"$fmt"'", $5, $6); \}'
\par ) 2>/dev/null
\par \}
\par 
\par \plain \f1\fs20\cf1 # Check whether file $1 is a backup or rpm-generated file and should be ignored
\par \plain \f1\fs20 is_ignored_file() \{
\par     case "$1" in
\par         *~ | *.bak | *.orig | *.rpmnew | *.rpmorig | *.rpmsave)
\par             return 0
\par             ;;
\par     esac
\par     return 1
\par \}
\par 
\par \plain \f1\fs20\cf1 # Evaluate shvar-style booleans
\par \plain \f1\fs20 is_true() \{
\par     case "$1" in
\par         [tT] | [yY] | [yY][eE][sS] | [tT][rR][uU][eE])
\par         return 0
\par         ;;
\par     esac
\par     return 1
\par \}
\par \plain \f1\fs20\cf1 
\par # Evaluate shvar-style booleans
\par \plain \f1\fs20 is_false() \{
\par     case "$1" in
\par         [fF] | [nN] | [nN][oO] | [fF][aA][lL][sS][eE])
\par         return 0
\par         ;;
\par     esac
\par     return 1
\par \}
\par 
\par \plain \f1\fs20\cf1 key_is_random() \{
\par \plain \f1\fs20     [ "$1" = "/dev/urandom" -o "$1" = "/dev/hw_random" \\
\par         -o "$1" = "/dev/random" ]
\par \}
\par 
\par \plain \f1\fs20\cf1 find_crypto_mount_point() \{
\par \plain \f1\fs20     local fs_spec fs_file fs_vfstype remaining_fields
\par     local fs
\par     while read fs_spec fs_file remaining_fields; do
\par         if [ "$fs_spec" = "/dev/mapper/$1" ]; then
\par             echo $fs_file
\par             break;
\par         fi
\par     done < /etc/fstab
\par \}
\par 
\par \plain \f1\fs20\cf1 # Because of a chicken/egg problem, init_crypto must be run twice.  /var may be
\par # encrypted but /var/lib/random-seed is needed to initialize swap.
\par \plain \f1\fs20 init_crypto() \{
\par     local have_random dst src key opt mode owner params makeswap skip arg opt
\par     local param value rc ret mke2fs mdir prompt mount_point
\par 
\par     ret=0
\par     have_random=$1
\par     while read dst src key opt; do
\par         [ -z "$dst" -o "$\{dst#\\#\}" != "$dst" ] && continue
\par         [ -b "/dev/mapper/$dst" ] && continue;
\par         if [ "$have_random" = 0 ] && key_is_random "$key"; then
\par             continue
\par         fi
\par         if [ -n "$key" -a "x$key" != "xnone" ]; then
\par             if test -e "$key" ; then
\par                 owner=$(ls -l $key | (read a b owner rest; echo $owner))
\par                 if ! key_is_random "$key"; then
\par                     mode=$(ls -l "$key" | cut -c 5-10)
\par                     if [ "$mode" != "------" ]; then
\par                        echo $"INSECURE MODE FOR $key"
\par                     fi
\par                 fi
\par                 if [ "$owner" != root ]; then
\par                     echo $"INSECURE OWNER FOR $key"
\par                 fi
\par             else
\par                 echo $"Key file for $dst not found, skipping"
\par                 ret=1
\par                 continue
\par             fi
\par         else
\par             key=""
\par         fi
\par         params=""
\par         makeswap=""
\par         mke2fs=""
\par         skip=""
\par         # Parse the src field for UUID= and convert to real device names
\par         if [ "$\{src%%=*\}" == "UUID" ]; then
\par                 src=$(/sbin/blkid -t "$src" -l -o device)
\par         elif [ "$\{src/^\\/dev\\/disk\\/by-uuid\\/\}" != "$src" ]; then
\par                 src=$(__readlink $src)
\par         fi
\par         # Is it a block device?
\par         [ -b "$src" ] || continue
\par         # Is it already a device mapper slave? (this is gross)
\par         devesc=$\{src##/dev/\}
\par         devesc=$\{devesc//\\//!\}
\par         for d in /sys/block/dm-*/slaves ; do
\par             [ -e $d/$devesc ] && continue 2
\par         done
\par         # Parse the options field, convert to cryptsetup parameters and
\par         # contruct the command line
\par         while [ -n "$opt" ]; do
\par             arg=$\{opt%%,*\}
\par             opt=$\{opt##$arg\}
\par             opt=$\{opt##,\}
\par             param=$\{arg%%=*\}
\par             value=$\{arg##$param=\}
\par 
\par             case "$param" in
\par             cipher)
\par                 params="$params -c $value"
\par                 if [ -z "$value" ]; then
\par                     echo $"$dst: no value for cipher option, skipping"
\par                     skip="yes"
\par                 fi
\par             ;;
\par             size)
\par                 params="$params -s $value"
\par                 if [ -z "$value" ]; then
\par                     echo $"$dst: no value for size option, skipping"
\par                     skip="yes"
\par                 fi
\par             ;;
\par             hash)
\par                 params="$params -h $value"
\par                 if [ -z "$value" ]; then
\par                     echo $"$dst: no value for hash option, skipping"
\par                     skip="yes"
\par                 fi
\par             ;;
\par             verify)
\par                 params="$params -y"
\par             ;;
\par             swap)
\par                 makeswap=yes
\par                 ;;
\par             tmp)
\par                 mke2fs=yes
\par             esac
\par         done
\par         if [ "$skip" = "yes" ]; then
\par             ret=1
\par             continue
\par         fi
\par         if [ -z "$makeswap" ] && cryptsetup isLuks "$src" 2>/dev/null ; then
\par             if key_is_random "$key"; then
\par                 echo $"$dst: LUKS requires non-random key, skipping"
\par                 ret=1
\par                 continue
\par             fi
\par             if [ -n "$params" ]; then
\par                 echo "$dst: options are invalid for LUKS partitions," \\
\par                     "ignoring them"
\par             fi
\par             if [ -n "$key" ]; then
\par                 /sbin/cryptsetup -d $key luksOpen "$src" "$dst" <&1 2>/dev/null && success || failure
\par                 rc=$?
\par             else
\par                 mount_point="$(find_crypto_mount_point $dst)"
\par                 [ -n "$mount_point" ] || mount_point=$\{src##*/\}
\par                 prompt=$(printf $"%s is password protected" "$mount_point")
\par                 plymouth ask-for-password --prompt "$prompt" --command="/sbin/cryptsetup luksOpen -T1 $src $dst" <&1
\par                 rc=$?
\par             fi
\par         else
\par             [ -z "$key" ] && plymouth --hide-splash
\par             /sbin/cryptsetup $params $\{key:+-d $key\} create "$dst" "$src" <&1 2>/dev/null && success || failure
\par             rc=$?
\par             [ -z "$key" ] && plymouth --show-splash
\par         fi
\par         if [ $rc -ne 0 ]; then
\par             ret=1
\par             continue
\par         fi
\par         if [ -b "/dev/mapper/$dst" ]; then
\par             if [ "$makeswap" = "yes" ]; then
\par                 mkswap "/dev/mapper/$dst" 2>/dev/null >/dev/null
\par             fi
\par             if [ "$mke2fs" = "yes" ]; then
\par                 if mke2fs "/dev/mapper/$dst" 2>/dev/null >/dev/null \\
\par                     && mdir=$(mktemp -d /tmp/mountXXXXXX); then
\par                     mount "/dev/mapper/$dst" "$mdir" && chmod 1777 "$mdir"
\par                     umount "$mdir"
\par                     rmdir "$mdir"
\par                 fi
\par             fi
\par         fi
\par     done < /etc/crypttab
\par     return $ret
\par \}
\par 
\par \plain \f1\fs20\cf1 # A sed expression to filter out the files that is_ignored_file recognizes
\par \plain \f1\fs20 __sed_discard_ignored_files='/\\(~\\|\\.bak\\|\\.orig\\|\\.rpmnew\\|\\.rpmorig\\|\\.rpmsave\\)$/d'\par}