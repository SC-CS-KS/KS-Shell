{\rtf1\fbidis\ansi\ansicpg0\uc1\deff0\deflang0\deflangfe0{\fonttbl{\f0\fnil \'cb\'ce\'cc\'e5;}{\f1\fnil \'ce\'a2\'c8\'ed\'d1\'c5\'ba\'da;}{\f2\fnil\fcharset134 \'cb\'ce\'cc\'e5;}{\f3\fnil Arial;}}{\colortbl;\red0\green0\blue255;\red255\green0\blue0;\red0\green0\blue0;\red255\green255\blue255;}{\*\listtable{\list\listtemplateid475235683\listsimple1
{\listlevel\levelnfc23\leveljc0\li720\fi-360\jclisttab\tx720{\leveltext\'00;}{\levelnumbers;}\f3\fs24}
\listid1770597107}
{\list\listtemplateid1165486278\listsimple1
{\listlevel\levelnfc23\leveljc0\li720\fi-360\jclisttab\tx720{\leveltext\'00;}{\levelnumbers;}\f3\fs24}
\listid764815331}
{\list\listtemplateid731649393\listsimple1
{\listlevel\levelnfc0\leveljc0\li720\fi-360\jclisttab\tx720\levelstartat1{\leveltext\'02\'00.;}{\levelnumbers\'01;}\f3\fs24}
\listid279655226}
}
{\*\listoverridetable
{\listoverride\listid1770597107\listoverridecount0\ls1}
{\listoverride\listid764815331\listoverridecount0\ls2}
{\listoverride\listid279655226\listoverridecount0\ls3}
}


\pard\fi420\li0\qc\ri0\sb0\sa0\itap0 \plain \f2\b\lang2052\fs24\cf3 Process Substitution and Pipes
\par \pard\fi420\li0\ql\ri0\sb0\sa0\itap0 
\par \plain \f1\b\fs20 Process Substitution and Pipes
\par \plain \f1\fs20 Posted on March 22, 2012
\par \plain \f1\fs20\cf2 Command substitution \plain \f1\fs20\cf1 is a widely used feature of the Bash and Korn shells\plain \f1\fs20 , 
\par allowing the output of one command to be captured and used in another. 
\par Like this:
\par bash-4.2$\plain \f1\fs20\cf1  echo \ldblquote Backup started at $(date)\rdblquote 
\par \plain \f1\fs20 Backup started at Fri Mar 16 15:35:14 GMT 2012
\par 
\par Command substitution is not to be confused with that less well known (and, if we\rquote re honest, less useful) shell feature, process substitution. Despite being rarely used, process substitution is worth knowing about, if only because it \plain \f1\fs20\cf1 illuminates other fundamental unix features \plain \f1\fs20 \endash \plain \f1\fs20\cf2  the shell, sub processes, named and unnamed pipes.
\par 
\par \plain \f1\fs20 This post discusses \plain \f1\fs20\cf1 process substitution\plain \f1\fs20 , \plain \f1\fs20\cf1 command substitution\plain \f1\fs20  and the\plain \f1\fs20\cf2  vertical bar (|)\plain \f1\fs20 . 
\par Three very different shell features, but all \plain \f1\fs20\cf1 making use of unnamed pipes\plain \f1\fs20 , and so not as different as they first appear.
\par \pard\fi0\li0\ql\ri0\sb0\sa0\itap0        The examples are from Linux but also work on Solaris 10 and, due to the \plain \f1\fs20\cf1 ubiquity\plain \f1\fs20 \uc2\u12304 \'a1\'be\u26222 \'c6\'d5\u36941 \'b1\'e9\u23384 \'b4\'e6\u22312 \'d4\'da\u12305 \'a1\'bf of pipes, are likely to work on other unixes too.\uc1
\par \pard\fi420\li0\ql\ri0\sb0\sa0\itap0 
\par \plain \f1\b\fs20 PROCESS SUBSTITUTION
\par \plain \f1\fs20 Process substitution is a command syntax \plain \f1\fs20\cf1 allowing the input/output of one command to be connected to the input/output of several other commands.\plain \f1\fs20  But first, a quick word about pipes. Consider a straightforward pipe like this one:
\par 
\par bash-4.2$ ls -l | sort -n -k 5
\par 
\par It produces a list of files sorted by size. The output of \ldblquote ls\rdblquote  is connected to the input of \ldblquote sort\rdblquote . This kind of pipe, represented by a vertical bar (|), connects just one command to exactly one other command. Process substitution gets around that limitation, \plain \f1\fs20\cf1 allowing \ldblquote one to many\rdblquote  connections between commands.
\par \plain \f1\fs20 
\par \plain \f1\b\fs20 Process Substitution Example (Input)
\par \plain \f1\fs20 For example, let\rquote s connect the output of \ldblquote ls\rdblquote  and the output of \ldblquote df\rdblquote  to the input of that sort. \plain \f1\fs20\cf1 Use the Process substitution input syntax, \ldblquote <()".
\par \plain \f1\fs20 
\par bash-4.2$ \plain \f1\fs20\cf1 sort -n -k 5 <(ls -l) <(df -k)
\par \plain \f1\fs20 
\par The "ls\rdblquote  and the \ldblquote df\rdblquote  now both execute and their outputs are both fed into the input of \ldblquote sort\ldblquote . 
\par (NB the output produced is silly, but this is just a demo of the command).
\par 
\par \plain \f1\b\fs20 COMMANDS AMENABLE TO PROCESS SUBSTITUTION
\par \plain \f1\fs20 Process substitution is \plain \f1\fs20\cf1 usually used in conjunction with a command that can take multiple file names as arguments.
\par Such as sort, which takes a list of files on the command line\plain \f1\fs20 . 
\par In the above example, the first \ldblquote file\rdblquote  argument to sort is \ldblquote <(ls -l)\ldblquote , which represents the output of \ldblquote ls -l\ldblquote . 
\par The second file argument to sort is \ldblquote <(df -k)\ldblquote , which represents the output of the \ldblquote df -k\rdblquote  command.
\par 
\par That was \ldblquote input\rdblquote  process substitution, using the \ldblquote input\rdblquote  process substitution syntax syntax \ldblquote <()". 
\par \plain \f1\fs20\cf1 The converse process is "output" process substitution, and uses the syntax ">()\plain \f1\fs20 \rdblquote . 
\par \plain \f1\fs20\cf2 Output process substitution is best demonstrated with a command that works with more than one output file\plain \f1\fs20 . 
\par There are a few to choose from but the most appropriate is probably tee.
\par 
\par \plain \f1\b\fs20 PROCESS SUBSTITUTION EXAMPLE (OUTPUT)
\par \plain \f1\fs20\cf1 Tee\lquote s function is to replicate it\rquote s standard output into every file that you name on the command line\plain \f1\fs20 . 
\par It is therefore well suited to work with output process substitution. 
\par That is, we can use tee to\plain \f1\fs20\cf1  connect the output of one command to the inputs of several others.
\par \plain \f1\fs20 
\par Eg. connect the output of one \ldblquote ls\rdblquote  to each of the inputs of two greps:
\par bash-4.2$ ls | \plain \f1\fs20\cf1 tee >(grep jpg > list.jpg) >(grep pdf > list.pdf)
\par \plain \f1\fs20 
\par A file \ldblquote list.pdf\rdblquote  is produced containing a list of all pdf files in the current directory. While \ldblquote list.jpg\rdblquote  contains the files of type jpg.
\par 
\par The above command uses the output command substitution syntax >(). 
\par The expression \ldblquote >(grep jpg > list.jpg)\rdblquote \plain \f1\fs20\cf1  is used as the first of tee\rquote s output files\plain \f1\fs20 , and \ldblquote >(grep pdf > list.pdf)\rdblquote  the second. 
\par The complete ls output is thus fed into both greps, producing the files described.
\par 
\par \plain \f1\b\fs20 USES OF PROCESS SUBSTITUTION
\par \plain \f1\fs20 We could go on to produce more elaborate examples of process substitution, perhaps substituting both input and output in the same command, nesting the syntax, using longer pipelines and so forth. I am not going to do that, for two reasons:
\par 
\par 1. Process substitution is not awfully useful. Anything it can do is better done with simpler commands.
\par 
\par 2. Process substitution syntax is excessive. If you want your scripts to be readable and maintainable, don\rquote t pepper them with idioms like \ldblquote ls | tee >(grep jpg > list.jpg) >(grep pdf > list.pdf)\rdblquote , or worse. A script written in that way would quickly become unmaintainable, even by its original author.
\par 
\par However, Process substitution is worth understanding because of the lights it sheds on processes and pipes.
\par 
\par HOW A UNIX PIPE WORKS
\par In the shell, pipes come in two flavours: named and unnamed. The example given at the start of this article was an unnamed pipe. Here it is again.
\par 
\par bash-4.2$ ls -l | sort -n -k 5
\par 
\par When the above command is run, the output of \ldblquote ls\rdblquote  is connected to the input of \ldblquote sort\rdblquote  via the pipe. The kernel runs the ls command and sends its output into a small area of memory called a FIFO buffer (first in first out). Meanwhile the input of the sort is connected to the other end of the FIFO. The sort process then goes to sleep while waiting for the ls output to appear in the pipe. When the ls output appears, the sort will wake up and begin to process it. If the FIFO fills up then the ls will go to sleep, and will only re-awaken when there is room in the pipe to push more data in.
\par 
\par \plain \f1\b\fs20 SLOW MOTION EXAMPLE \endash  UNNAMED PIPE
\par \plain \f1\fs20 To see this happening, we need a slow pipeline. How about this:
\par 
\par bash-4.2$ sleep 3600 | cat &
\par [1] 3080
\par 
\par It does nothing meaningful, just sets up the pipe, waits for an hour then exits. Check it in another window:
\par 
\par bash-4.2$ ps -elf | grep 3080
\par 0 S james 3080 2049 0 80 0 \endash  1060 pipe_w 17:22 pts/2 00:00:00 cat
\par 
\par There is the cat, waiting patiently. The \ldblquote S\rdblquote  in the second column and the flag \ldblquote pipe_w\rdblquote  shows that the cat process is \ldblquote sleeping on the pipe\rdblquote . We can look at the pipe inode too:
\par 
\par bash-4.2$ ls -li /proc/3080/fd
\par total 0
\par 842398 lr-x\emdash \emdash . 1 james james 64 Mar 16 17:29 0 -> pipe:[809936]
\par 842399 lrwx\emdash \emdash . 1 james james 64 Mar 16 17:29 1 -> /dev/pts/2
\par 810251 lrwx\emdash \emdash . 1 james james 64 Mar 16 17:23 2 -> /dev/pts/2
\par 
\par The standard input of the cat (process 3080) is associated with a pipe inode, inode number 809936. All unix pipes (and all files) are associated with a inode. This inode is part of the /proc file system. (Ignore the other inode numbers on the left. They just correspond to the soft links 0, 1 and 2).
\par 
\par Since the pipe is \ldblquote unnamed\rdblquote , it has no associated name in the file system. The find command (run while cat is still sleeping) verifies that, by finding no file with inode number 809936
\par 
\par bash-4.2$ sudo find /proc -iname 809936
\par bash-4.2$
\par 
\par That\rquote s he end of the test, so just to kill those outstanding processes:
\par 
\par bash-4.2$ kill %1
\par 
\par \plain \f1\b\fs20 SLOW MOTION EXAMPLE \endash  NAMED PIPE
\par \plain \f1\fs20 Once it has been established, a named pipe works in exactly the same way as unnamed pipe. But it has something the unnamed pipe doesn\rquote t: a name in the file system. To make a unnamed pipe (aka a fifo), use the mkfifo command:
\par 
\par bash-4.2$ cd /tmp
\par bash-4.2$ mkfifo testfifo
\par 
\par The following ls command shows a \ldblquote p\rdblquote  on the left, indicating a special device of type \ldblquote pipe\rdblquote .
\par 
\par bash-4.2$ ls -l testfifo
\par prw-rw-r\endash . 1 james james 0 Mar 20 11:21 testfifo
\par 
\par Now to repeat the above test. Again, using a \ldblquote sleep\rdblquote  command will slow things down. Direct the output of sleep into the pipe as follows. (Sleep doesn\rquote t make any output, it is just useful for this demonstration).
\par 
\par bash-4.2$ sleep 3600 > testfifo &
\par [1] 2775
\par 
\par Now set up a \ldblquote cat\rdblquote  command to read the pipe output, completing the pipeline.
\par 
\par bash-4.2$ cat testfifo &
\par [2] 2785
\par 
\par As before, check to see what cat is doing. As expected, it is sleeping on the pipe:
\par 
\par bash-4.2$ ps -elf | grep cat
\par 0 S james 2785 2123 0 80 0 \endash  1060 pipe_w 11:58 pts/0 00:00:00 cat testfifo
\par 
\par Only this time, the pipe has a name, viz. /tmp/testfifo. Have a look at the file descriptors belonging to the cat process, and there it is:
\par 
\par bash-4.2$ ls -li /proc/2785/fd
\par total 0
\par 253425 lrwx\emdash \emdash . 1 james james 64 Mar 20 12:04 0 -> /dev/pts/0
\par 253426 lrwx\emdash \emdash . 1 james james 64 Mar 20 12:04 1 -> /dev/pts/0
\par 247244 lrwx\emdash \emdash . 1 james james 64 Mar 20 12:02 2 -> /dev/pts/0
\par 253427 lr-x\emdash \emdash . 1 james james 64 Mar 20 12:04 3 -> /tmp/testfifo
\par 
\par This time, file descriptor of interest is numbered 3 and the soft link points not just to an inode, but to the associated name \endash  /tmp/testfifo. lsof will provide more information:
\par 
\par bash-4.2$ ls -li /tmp/testfifo
\par 22698 prw-rw-r\endash . 1 james james 0 Mar 20 11:38 /tmp/testfifo
\par bash-4.2$ lsof | grep testfifo
\par sleep 2775 james 1u FIFO 8,5 0t0 22698 /tmp/testfifo
\par cat 2785 james 3r FIFO 8,5 0t0 22698 /tmp/testfifo
\par 
\par As expected, the fifo /tmp/testfifo is currently open for reading and writing on the standard output of sleep (as evinced by the \ldblquote 1u\rdblquote  in the FD column of lsof. Meanwhile the cat process has the fifo open on file descriptor 3 for reading only. Looking at the pipe, it almost seems that the cat should be reading from file descriptor 1, its standard input. Not so. Recall the name of the pipe was given to cat as an argument, not as a stream to standard in. Cat therefore opened the pipe using the first free file descriptor, which was number 3.
\par 
\par \plain \f1\b\fs20 NAMED PIPE AVAILABLE TO OTHER PROCESSES
\par \plain \f1\fs20 While the above processes are sleeping, the named pipe is still available for other input. Because it has a name in the file system, it can be accessed by other processes. Eg. Send the output of ls into it, and the file listing appears in the shell:
\par 
\par bash-4.2$ ls > testfifo
\par file1
\par file2
\par \uc2\u8230 \'a1\'ad\uc1
\par 
\par The cat woke up briefly, printed the ls output, then slept again, waiting for more output from the pipe. The two original processes are still there:
\par 
\par bash-4.2$ ps -elf | egrep \ldblquote cat|sleep\rdblquote 
\par 0 S james 2775 2123 0 80 0 \endash  1055 hrtime 12:23 pts/0 00:00:00 sleep 1000
\par 0 S james 2785 2123 0 80 0 \endash  1060 pipe_w 12:23 pts/0 00:00:00 cat testfifo
\par 
\par Cleaning Up
\par Kill those test processes. And the named pipe will continue to exist even through a reboot, unless it is removed now:
\par 
\par bash-4.2$ kill %1
\par bash-4.2$ rm /tmp/testfifo
\par 
\par \plain \f1\b\fs20 PROCESS SUBSTITUTION USES UNNAMED PIPES
\par \plain \f1\fs20 Just as the above tests showed the bar (|) using unnamed pipes, so process substitution can be seen using them, if things are slowed down enough. The following example makes no practical sense, it is just useful as a demonstration.
\par 
\par bash-4.2$ sort -n -k 5 <(sleep 3600) <(ls -l) &
\par [1] 3061
\par 
\par Use ps to check the sort process (pid 3061). The above command line can be seen after the sleep and ls commands have been substituted with /dev/fd/63 and /def/fd/62. These are unnamed pipes receiving input from the sleep and ls commands.
\par 
\par ash-4.2$ ps -ef | grep 3061
\par james 3061 1987 0 18:02 pts/1 00:00:00 sort -n -k 5 /dev/fd/63 /dev/fd/62
\par 
\par More correctly, they are soft links pointing to unnamed pipes that the sort process has open for reading. Checking the sort process under /proc, the unnamed pipes are associated with inodes 538039 and 538040.
\par 
\par bash-4.2$ ls -l /proc/3061/fd
\par total 0
\par lrwx------. 1 james james 64 Mar 20 18:05 0 -> /dev/pts/1
\par lrwx\emdash \emdash . 1 james james 64 Mar 20 18:05 1 -> /dev/pts/1
\par lrwx\emdash \emdash . 1 james james 64 Mar 20 18:02 2 -> /dev/pts/1
\par lr-x\emdash \emdash . 1 james james 64 Mar 20 18:05 3 -> pipe:[538039]
\par lr-x\emdash \emdash . 1 james james 64 Mar 20 18:02 62 -> pipe:[538040]
\par lr-x\emdash \emdash . 1 james james 64 Mar 20 18:02 63 -> pipe:[538039]
\par 
\par The kernel has taken two inodes from the pipe device (/proc) and used them to create the necessary unnamed pipes. A sub shell (pid
\par 
\par \plain \f1\b\fs20 EVEN COMMAND SUBSTITUTION USES UNNAMED PIPES
\par \plain \f1\fs20 The test above, showing the vertical bar (|) using unnamed pipes, can be repeated for command substitution:
\par 
\par bash-4.2$ /bin/echo \ldblquote That was a nice sleep $(sleep 3600)\rdblquote  &
\par [1] 3132
\par 
\par Again, the command is pointless but useful as a demonstration. Checking the processes involved:
\par 
\par bash-4.2$ ps -elf | grep 3132
\par james 3132 1987 0 18:28 pts/1 00:00:00 bash
\par james 3133 3132 0 18:28 pts/1 00:00:00 sleep 3600
\par 
\par Process 3132 is a bash shell sub process spawned to handle the sleep command. Looking into the file descriptors of both processes:
\par 
\par bash-4.2$ ls -l /proc/3133/fd
\par total 0
\par lrwx\emdash \emdash . 1 james james 64 Mar 20 18:28 0 -> /dev/pts/1
\par l-wx\emdash \emdash . 1 james james 64 Mar 20 18:28 1 -> pipe:[585486]
\par lrwx\emdash \emdash . 1 james james 64 Mar 20 18:28 2 -> /dev/pts/1
\par 
\par bash-4.2$ ls -l /proc/3132/fd
\par total 0
\par lrwx\emdash \emdash . 1 james james 64 Mar 20 18:28 0 -> /dev/pts/1
\par lrwx\emdash \emdash . 1 james james 64 Mar 20 18:28 1 -> /dev/pts/1
\par lrwx\emdash \emdash . 1 james james 64 Mar 20 18:28 2 -> /dev/pts/1
\par lrwx\emdash \emdash . 1 james james 64 Mar 20 18:28 255 -> /dev/pts/1
\par lr-x\emdash \emdash . 1 james james 64 Mar 20 18:28 3 -> pipe:[585486]
\par 
\par \uc2\u8230 \'a1\'adshows that they are connected by an unnamed pipe with inode 585486. The kernel has taken this inode from the pipe device /proc to handle communication between the processes.\uc1
\par 
\par \plain \f1\b\fs20 CONCLUSION
\par \plain \f1\fs20 Process substitution, command substitution and the vertical bar (|) are all implemented using unnamed pipes. It is sometimes written that command substitution uses named pipes. While that was true in the past (eg. 1997) it no longer seems to be so at the time of writing (March 2012).
\par 
\par Process substitution is used very rarely, command substitution is common, especially within scripts, and the most widely used of all is the vertical bar (|), perhaps the most useful item in the whole of Unix.
\par 
\par Named pipes are infrequently used, sometimes appearing where a command can read or write only to a file, and the user therefore substitutes the name of the pipe for the file. Or in the making of database dumps or other communication between applications and the OS.\par}