{\rtf1\fbidis\ansi\ansicpg0\uc1\deff0\deflang0\deflangfe0{\fonttbl{\f0\fnil \'cb\'ce\'cc\'e5;}{\f1\fnil \'ce\'a2\'c8\'ed\'d1\'c5\'ba\'da;}{\f2\fnil\fcharset134 \'cb\'ce\'cc\'e5;}{\f3\fnil Arial;}}{\colortbl;\red0\green0\blue255;\red0\green0\blue0;\red255\green255\blue255;}{\*\listtable{\list\listtemplateid1097097797\listsimple1
{\listlevel\levelnfc23\leveljc0\li720\fi-360\jclisttab\tx720{\leveltext\'00;}{\levelnumbers;}\f3\fs24}
\listid1339442528}
}
{\*\listoverridetable
{\listoverride\listid1339442528\listoverridecount0\ls1}
}


\pard\fi420\li0\qc\ri0\sb0\sa0\itap0 \plain \f2\b\lang2052\fs24\cf2 03.Shell Parameter Expansion
\par \pard\fi420\li0\ql\ri0\sb0\sa0\itap0 
\par \plain \f1\fs20    Parameter Expansion
\par        The  '$'  character  introduces  parameter  expansion,  command  substitution, or arithmetic expansion.  The parameter name or symbol to be expanded may be enclosed in braces, which are optional but serve to protect the variable to be expanded from characters immediately following it which could be interpreted as part of the name.
\par 
\par        When  braces  are  used, the matching ending brace is the first '\}' not escaped by a backslash or within a quoted string, and not within an
\par        embedded arithmetic expansion, command substitution, or paramter expansion.
\par 
\par        $\{parameter\}
\par               The value of parameter is substituted.  The braces are required when parameter is a positional parameter with more than  one  digit,
\par               or when parameter is followed by a character which is not to be interpreted as part of its name.
\par 
\par        If  the  first  character  of parameter is an exclamation point, a level of variable indirection is introduced.  Bash uses the value of the
\par        variable formed from the rest of parameter as the name of the variable; this variable is then expanded and that value is used in  the  rest
\par        of  the  substitution,  rather  than  the  value of parameter itself.  This is known as indirect expansion.  The exceptions to this are the
\par        expansions of $\{!prefix*\} and $\{!name[@]\} described below.  The exclamation point must immediately follow the left brace in order to intro-
\par        duce indirection.
\par 
\par        In  each of the cases below, word is subject to tilde expansion, parameter expansion, command substitution, and arithmetic expansion.  When
\par        not performing substring expansion, bash tests for a parameter that is unset or null; omitting the colon results  in  a  test  only  for  a
\par        parameter that is unset.
\par 
\par        $\{parameter:-word\}
\par               Use Default Values.  If parameter is unset or null, the expansion of word is substituted.  Otherwise, the value of parameter is sub-
\par               stituted.
\par        $\{parameter:=word\}
\par               Assign Default Values.  If parameter is unset or null, the expansion of word is assigned to parameter.  The value  of  parameter  is
\par               then substituted.  Positional parameters and special parameters may not be assigned to in this way.
\par        $\{parameter:?word\}
\par               Display  Error  if  Null or Unset.  If parameter is null or unset, the expansion of word (or a message to that effect if word is not
\par               present) is written to the standard error and the shell, if it is not interactive, exits.  Otherwise, the value of parameter is sub-
\par               stituted.
\par        $\{parameter:+word\}
\par               Use Alternate Value.  If parameter is null or unset, nothing is substituted, otherwise the expansion of word is substituted.
\par        $\{parameter:offset\}
\par        $\{parameter:offset:length\}
\par               Substring  Expansion.   Expands to up to length characters of parameter starting at the character specified by offset.  If length is
\par               omitted, expands to the substring of parameter starting at the character specified by offset.   length  and  offset  are  arithmetic
\par               expressions (see ARITHMETIC EVALUATION below).  length must evaluate to a number greater than or equal to zero.  If offset evaluates
\par               to a number less than zero, the value is used as an offset from the end of the value of parameter.  If parameter is @, the result is
\par               length positional parameters beginning at offset.  If parameter is an array name indexed by @ or *, the result is the length members
\par               of the array beginning with $\{parameter[offset]\}.  Substring indexing is zero-based unless the positional parameters  are  used,  in
\par               which case the indexing starts at 1.
\par 
\par        $\{!prefix*\}
\par        $\{!prefix@\}
\par               Expands to the names of variables whose names begin with prefix, separated by the first character of the IFS special variable.
\par 
\par        $\{!name[@]\}
\par        $\{!name[*]\}
\par               If  name  is an array variable, expands to the list of array indices (keys) assigned in name.  If name is not an array, expands to 0
\par               if name is set and null otherwise.  When @ is used and the expansion appears within double quotes, each key expands  to  a  separate
\par               word.
\par 
\par        $\{#parameter\}
\par               The  length  in characters of the value of parameter is substituted.  If parameter is * or @, the value substituted is the number of
\par               positional parameters.  If parameter is an array name subscripted by * or @, the value substituted is the number of elements in  the
\par               array.
\par 
\par        $\{parameter#word\}
\par        $\{parameter##word\}
\par               The  word  is  expanded  to  produce  a pattern just as in pathname expansion.  If the pattern matches the beginning of the value of
\par               parameter, then the result of the expansion is the expanded value of parameter with the shortest matching pattern (the  ''#''  case)
\par               or the longest matching pattern (the ''##'' case) deleted.  If parameter is @ or *, the pattern removal operation is applied to each
\par               positional parameter in turn, and the expansion is the resultant list.  If parameter is an array variable subscripted with @  or  *,
\par               the pattern removal operation is applied to each member of the array in turn, and the expansion is the resultant list.
\par 
\par        $\{parameter%word\}
\par        $\{parameter%%word\}
\par               The  word is expanded to produce a pattern just as in pathname expansion.  If the pattern matches a trailing portion of the expanded
\par               value of parameter, then the result of the expansion is the expanded value of parameter with  the  shortest  matching  pattern  (the
\par               ''%''  case)  or  the  longest matching pattern (the ''%%'' case) deleted.  If parameter is @ or *, the pattern removal operation is
\par               applied to each positional parameter in turn, and the expansion is the resultant list.  If  parameter  is  an  array  variable  sub-
\par               scripted  with @ or *, the pattern removal operation is applied to each member of the array in turn, and the expansion is the resul-
\par               tant list.
\par 
\par        $\{parameter/pattern/string\}
\par        $\{parameter//pattern/string\}
\par               The pattern is expanded to produce a pattern just as in pathname expansion.  Parameter is expanded and the longest match of  pattern
\par               against its value is replaced with string.  In the first form, only the first match is replaced.  The second form causes all matches
\par               of pattern to be replaced with string.  If pattern begins with #, it must match at the beginning of the expanded value of parameter.
\par               If  pattern  begins  with %, it must match at the end of the expanded value of parameter.  If string is null, matches of pattern are
\par               deleted and the / following pattern may be omitted.  If parameter is @ or *, the substitution operation is  applied  to  each  posi-
\par               tional  parameter  in turn, and the expansion is the resultant list.  If parameter is an array variable subscripted with @ or *, the
\par               substitution operation is applied to each member of the array in turn, and the expansion is the resultant list.\par}