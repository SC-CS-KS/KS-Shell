{\rtf1\fbidis\ansi\ansicpg0\uc1\deff0\deflang0\deflangfe0{\fonttbl{\f0\fnil \'cb\'ce\'cc\'e5;}{\f1\fnil \'ce\'a2\'c8\'ed\'d1\'c5\'ba\'da;}{\f2\fnil\fcharset134 \'cb\'ce\'cc\'e5;}{\f3\fnil\fcharset0 Times New Roman;}}{\colortbl;\red0\green0\blue255;\red0\green0\blue0;\red79\green129\blue189;\red255\green255\blue255;}{\*\listtable{\list\listtemplateid1552059886
{\listlevel\levelnfc0\leveljc0\li0\fi0\jclisttab\tx0\levelstartat1{\leveltext\'00;}{\levelnumbers;}\f3\fs24}
{\listlevel\levelnfc0\leveljc0\li0\fi0\jclisttab\tx0\levelstartat1{\leveltext\'00;}{\levelnumbers;}\f3\b\i\fs28}
{\listlevel\levelnfc0\leveljc0\li0\fi0\jclisttab\tx0\levelstartat1{\leveltext\'00;}{\levelnumbers;}\f3\fs24}
{\listlevel\levelnfc0\leveljc0\li0\fi0\jclisttab\tx0\levelstartat1{\leveltext\'00;}{\levelnumbers;}\f3\fs24}
{\listlevel\levelnfc0\leveljc0\li0\fi0\jclisttab\tx0\levelstartat1{\leveltext\'00;}{\levelnumbers;}\f3\fs24}
{\listlevel\levelnfc0\leveljc0\li0\fi0\jclisttab\tx0\levelstartat1{\leveltext\'00;}{\levelnumbers;}\f3\fs24}
{\listlevel\levelnfc0\leveljc0\li0\fi0\jclisttab\tx0\levelstartat1{\leveltext\'00;}{\levelnumbers;}\f3\fs24}
{\listlevel\levelnfc0\leveljc0\li0\fi0\jclisttab\tx0\levelstartat1{\leveltext\'00;}{\levelnumbers;}\f3\fs24}
{\listlevel\levelnfc0\leveljc0\li0\fi0\jclisttab\tx0\levelstartat1{\leveltext\'00;}{\levelnumbers;}\f3\fs24}
\listid120848811}
{\list\listtemplateid1581020761\listsimple1
{\listlevel\levelnfc0\leveljc0\li1380\fi-420\jclisttab\tx1380\levelstartat1{\leveltext\'02\'00);}{\levelnumbers\'01;}\f3\b\i\fs24\cf3}
\listid117749698}
}
{\*\listoverridetable
{\listoverride\listid120848811\listoverridecount0\ls1}
{\listoverride\listid117749698\listoverridecount0\ls2}
}


\pard\fi0\li0\qc\ri0\sb0\sa0\itap0 \plain \f2\b\lang2052\fs24\cf2 shUnit2 Code
\par \pard\fi0\li0\ql\ri0\sb0\sa0\itap0 
\par \plain \f1\fs20 # $Id: shunit2 151 2008-05-10 22:07:29Z sfsetse $
\par # vim:et:ft=sh:sts=2:sw=2
\par # vim:foldmethod=marker:foldmarker=/**,*/
\par #
\par #/**
\par # <?xml version="1.0" encoding="UTF-8"?>
\par # <s:shelldoc xmlns:s="http://www.forestent.com/projects/shelldoc/xsl/2005.0">
\par # <s:header>
\par # shUnit 2.1.3
\par # Shell Unit Test Framework
\par #
\par # http://shunit2.sourceforge.net/
\par #
\par # written by Kate Ward &lt;kate.ward@forestent.com&gt;
\par # released under the LGPL
\par #
\par # this module implements a xUnit based unit test framework similar to JUnit
\par # </s:header>
\par #*/
\par 
\par __SHUNIT_VERSION='2.1.3'
\par 
\par _shunit_warn() \{ echo "shunit2:WARN $@" >&2; \}
\par _shunit_error() \{ echo "shunit2:ERROR $@" >&2; \}
\par _shunit_fatal() \{ echo "shunit2:FATAL $@" >&2; \}
\par 
\par SHUNIT_TRUE=0
\par SHUNIT_FALSE=1
\par SHUNIT_ERROR=2
\par 
\par # specific shell checks
\par if [ -n "$\{ZSH_VERSION:-\}" ]; then
\par   if [ "`set -o |grep "^shwordsplit" |awk '\{print $2\}'`" = 'off' ]; then
\par     _shunit_fatal 'shwordsplit option required for proper zsh operation'
\par     exit $\{SHUNIT_ERROR\}
\par   fi
\par   if [ -z "$\{SHUNIT_PARENT:-\}" ]; then
\par     _shunit_fatal "zsh does not pass \\$0 through properly. please declare \\
\par \\"SHUNIT_PARENT=\\$0\\" before calling shUnit2"
\par     exit $\{SHUNIT_ERROR\}
\par   fi
\par fi
\par 
\par # shell flags for shunit2:
\par # u - treat unset variables as an error when performing parameter expansion
\par __SHUNIT_SHELL_FLAGS='u'
\par 
\par # save the current set of shell flags, and then set some for ourself
\par _shunit_shellFlags="$-"
\par for _shunit_shellFlag in `echo "$\{__SHUNIT_SHELL_FLAGS\}" |sed 's/\\(.\\)/\\1 /g'`
\par do
\par   set -$\{_shunit_shellFlag\}
\par done
\par 
\par #
\par # constants
\par #
\par 
\par __SHUNIT_ASSERT_MSG_PREFIX='ASSERT:'
\par __SHUNIT_PARENT=$\{SHUNIT_PARENT:-$0\}
\par 
\par # set the constants readonly
\par _shunit_constants=`set |grep "^__SHUNIT_" |cut -d= -f1`
\par echo "$\{_shunit_constants\}" |grep "^Binary file" >/dev/null
\par if [ $? -eq 0 ]; then
\par   # deal with binary junk in 'set' output
\par   _shunit_constants=`set |grep -a "^__SHUNIT_" |cut -d= -f1`
\par fi
\par for _shunit_const in $\{_shunit_constants\}; do
\par   if [ -n "$\{ZSH_VERSION:-\}" ]; then
\par     readonly -g $\{_shunit_const\}  # declare readonly constants globally
\par   else
\par     readonly $\{_shunit_const\}
\par   fi
\par done
\par unset _shunit_const _shunit_constants
\par 
\par # variables
\par __shunit_skip=$\{SHUNIT_FALSE\}
\par __shunit_suite=''
\par 
\par __shunit_testsPassed=0
\par __shunit_testsFailed=0
\par __shunit_testsSkipped=0
\par __shunit_testsTotal=0
\par 
\par #-----------------------------------------------------------------------------
\par # assert functions
\par #
\par 
\par #/**
\par # <s:function group="asserts">
\par # <entry align="right">
\par #   <emphasis>void</emphasis>
\par # </entry>
\par # <entry>
\par #   <funcsynopsis>
\par #     <funcprototype>
\par #       <funcdef><function>assertEquals</function></funcdef>
\par #       <paramdef>string <parameter>[message]</parameter></paramdef>
\par #       <paramdef>string <parameter>expected</parameter></paramdef>
\par #       <paramdef>string <parameter>actual</parameter></paramdef>
\par #     </funcprototype>
\par #   </funcsynopsis>
\par #   <para>Asserts that <emphasis>expected</emphasis> and
\par #   <emphasis>actual</emphasis> are equal to one another. The message is
\par #   optional.</para>
\par # </entry>
\par # </s:function>
\par #*/
\par assertEquals()
\par \{
\par   _shunit_shouldSkip && return $\{SHUNIT_TRUE\}
\par 
\par   _su_message=''
\par   if [ $# -lt 2 ]; then
\par     _shunit_error 'assertEquals()/assertSame() require at least two arguments'
\par     return $\{SHUNIT_ERROR\}
\par   elif [ $# -eq 3 ]; then
\par     _su_message=$1
\par     shift
\par   fi
\par   _su_expected=$\{1:-\}
\par   _su_actual=$\{2:-\}
\par 
\par   shunit_return=$\{SHUNIT_TRUE\}
\par   if [ "$\{_su_expected\}" = "$\{_su_actual\}" ]; then
\par     _shunit_testPassed
\par   else
\par     failNotEquals "$\{_su_message\}" "$\{_su_expected\}" "$\{_su_actual\}"
\par     shunit_return=$\{SHUNIT_FALSE\}
\par   fi
\par 
\par   unset _su_message _su_expected _su_actual
\par   return $\{shunit_return\}
\par \}
\par 
\par #/**
\par # <s:function group="asserts">
\par # <entry align="right">
\par #   <emphasis>void</emphasis>
\par # </entry>
\par # <entry>
\par #   <funcsynopsis>
\par #     <funcprototype>
\par #       <funcdef><function>assertNull</function></funcdef>
\par #       <paramdef>string <parameter>[message]</parameter></paramdef>
\par #       <paramdef>string <parameter>value</parameter></paramdef>
\par #     </funcprototype>
\par #   </funcsynopsis>
\par #   <para>Asserts that <emphasis>value</emphasis> is <literal>null</literal>,
\par #   or in shell terms a zero-length string. The message is optional.</para>
\par # </entry>
\par # </s:function>
\par #*/
\par assertNull()
\par \{
\par   _shunit_shouldSkip && return $\{SHUNIT_TRUE\}
\par 
\par   if [ $# -lt 1 ]; then
\par     _shunit_error 'assertNull() requires at least one arguments'
\par     return $\{SHUNIT_ERROR\}
\par   elif [ $# -eq 2 ]; then
\par     assertTrue "$1" "[ -z '$2' ]"
\par   else
\par     assertTrue "[ -z '$\{1:-\}' ]"
\par   fi
\par \}
\par 
\par #/**
\par # <s:function group="asserts">
\par # <entry align="right">
\par #   <emphasis>void</emphasis>
\par # </entry>
\par # <entry>
\par #   <funcsynopsis>
\par #     <funcprototype>
\par #       <funcdef><function>assertNotNull</function></funcdef>
\par #       <paramdef>string <parameter>[message]</parameter></paramdef>
\par #       <paramdef>string <parameter>value</parameter></paramdef>
\par #     </funcprototype>
\par #   </funcsynopsis>
\par #   <para>Asserts that <emphasis>value</emphasis> is <emphasis
\par #   role="strong">not</emphasis> <literal>null</literal>, or in shell terms not
\par #   a zero-length string. The message is optional.</para>
\par # </entry>
\par # </s:function>
\par #*/
\par assertNotNull()
\par \{
\par   _shunit_shouldSkip && return $\{SHUNIT_TRUE\}
\par 
\par   if [ $# -eq 2 ]; then
\par     assertTrue "$1" "[ -n '$2' ]"
\par   else
\par     assertTrue "[ -n '$\{1:-\}' ]"
\par   fi
\par \}
\par 
\par #/**
\par # <s:function group="asserts">
\par # <entry align="right">
\par #   <emphasis>void</emphasis>
\par # </entry>
\par # <entry>
\par #   <funcsynopsis>
\par #     <funcprototype>
\par #       <funcdef><function>assertSame</function></funcdef>
\par #       <paramdef>string <parameter>[message]</parameter></paramdef>
\par #       <paramdef>string <parameter>expected</parameter></paramdef>
\par #       <paramdef>string <parameter>actual</parameter></paramdef>
\par #     </funcprototype>
\par #   </funcsynopsis>
\par #   <para>This function is functionally equivalent to
\par #   <function>assertEquals</function>.</para>
\par # </entry>
\par # </s:function>
\par #*/
\par assertSame()
\par \{
\par   assertEquals "$\{@:-\}"
\par \}
\par 
\par #/**
\par # <s:function group="asserts">
\par # <entry align="right">
\par #   <emphasis>void</emphasis>
\par # </entry>
\par # <entry>
\par #   <funcsynopsis>
\par #     <funcprototype>
\par #       <funcdef><function>assertNotSame</function></funcdef>
\par #       <paramdef>string <parameter>[message]</parameter></paramdef>
\par #       <paramdef>string <parameter>unexpected</parameter></paramdef>
\par #       <paramdef>string <parameter>actual</parameter></paramdef>
\par #     </funcprototype>
\par #   </funcsynopsis>
\par #   <para>Asserts that <emphasis>unexpected</emphasis> and
\par #   <emphasis>actual</emphasis> are <emphasis role="strong">not</emphasis>
\par #   equal to one another. The message is optional.</para>
\par # </entry>
\par # </s:function>
\par #*/
\par assertNotSame()
\par \{
\par   _shunit_shouldSkip && return $\{SHUNIT_TRUE\}
\par 
\par   _su_message=''
\par   if [ $# -eq 3 ]; then
\par     _su_message=$1
\par     shift
\par   fi
\par   _su_unexpected=$\{1:-\}
\par   _su_actual=$\{2:-\}
\par 
\par   shunit_return=$\{SHUNIT_TRUE\}
\par   if [ "$\{_su_unexpected\}" != "$\{_su_actual\}" ]; then
\par     _shunit_testPassed
\par   else
\par     failSame "$\{_su_message\}"
\par     shunit_return=$\{SHUNIT_FALSE\}
\par   fi
\par 
\par   unset _su_message _su_unexpected _su_actual
\par   return $\{shunit_return\}
\par \}
\par 
\par #/**
\par # <s:function group="asserts">
\par # <entry align="right">
\par #   <emphasis>void</emphasis>
\par # </entry>
\par # <entry>
\par #   <funcsynopsis>
\par #     <funcprototype>
\par #       <funcdef><function>assertTrue</function></funcdef>
\par #       <paramdef>string <parameter>[message]</parameter></paramdef>
\par #       <paramdef>string <parameter>condition</parameter></paramdef>
\par #     </funcprototype>
\par #   </funcsynopsis>
\par #   <para>Asserts that a given shell test condition is true. The message is
\par #   optional.</para>
\par #   <para>Testing whether something is true or false is easy enough by using
\par #   the assertEquals/assertNotSame functions. Shell supports much more
\par #   complicated tests though, and a means to support them was needed. As such,
\par #   this function tests that conditions are true or false through evaluation
\par #   rather than just looking for a true or false.</para>
\par #   <funcsynopsis>
\par #     The following test will succeed: <funcsynopsisinfo>assertTrue "[ 34 -gt 23 ]"</funcsynopsisinfo>
\par #     The folloing test will fail with a message: <funcsynopsisinfo>assertTrue "test failed" "[ -r '/non/existant/file' ]"</funcsynopsisinfo>
\par #   </funcsynopsis>
\par # </entry>
\par # </s:function>
\par #*/
\par assertTrue()
\par \{
\par   _shunit_shouldSkip && return $\{SHUNIT_TRUE\}
\par 
\par   _su_message=''
\par   if [ $# -eq 2 ]; then
\par     _su_message=$1
\par     shift
\par   fi
\par   _su_condition=$\{1:-\}
\par 
\par   shunit_return=$\{SHUNIT_TRUE\}
\par 
\par   # see if condition is an integer, i.e. a return value
\par   _su_match=`expr "$\{_su_condition\}" : '\\([0-9]*\\)'`
\par   if [ -z "$\{_su_condition\}" ]; then
\par     # null condition
\par     shunit_return=$\{SHUNIT_FALSE\}
\par   elif [ "$\{_su_condition\}" = "$\{_su_match\}" ]; then
\par     # possible return value. treating 0 as true, and non-zero as false.
\par     [ $\{_su_condition\} -ne 0 ] && shunit_return=$\{SHUNIT_FALSE\}
\par   else
\par     # (hopefully) a condition
\par     ( eval $\{_su_condition\} ) >/dev/null 2>&1
\par     [ $? -ne 0 ] && shunit_return=$\{SHUNIT_FALSE\}
\par   fi
\par 
\par   # record the test
\par   if [ $\{shunit_return\} -eq $\{SHUNIT_TRUE\} ]; then
\par     _shunit_testPassed
\par   else
\par     _shunit_testFailed "$\{_su_message\}"
\par   fi
\par 
\par   unset _su_message _su_condition _su_match
\par   return $\{shunit_return\}
\par \}
\par 
\par #/**
\par # <s:function group="asserts">
\par # <entry align="right">
\par #   <emphasis>void</emphasis>
\par # </entry>
\par # <entry>
\par #   <funcsynopsis>
\par #     <funcprototype>
\par #       <funcdef><function>assertFalse</function></funcdef>
\par #       <paramdef>string <parameter>[message]</parameter></paramdef>
\par #       <paramdef>string <parameter>condition</parameter></paramdef>
\par #     </funcprototype>
\par #   </funcsynopsis>
\par #   <para>Asserts that a given shell test condition is false. The message is
\par #   optional.</para>
\par #   <para>Testing whether something is true or false is easy enough by using
\par #   the assertEquals/assertNotSame functions. Shell supports much more
\par #   complicated tests though, and a means to support them was needed. As such,
\par #   this function tests that conditions are true or false through evaluation
\par #   rather than just looking for a true or false.</para>
\par #   <funcsynopsis>
\par #     The following test will succeed: <funcsynopsisinfo>assertFalse "[ 'apples' = 'oranges' ]"</funcsynopsisinfo>
\par #     The folloing test will fail with a message: <funcsynopsisinfo>assertFalse "test failed" "[ 1 -eq 1 -a 2 -eq 2 ]"</funcsynopsisinfo>
\par #   </funcsynopsis>
\par # </entry>
\par # </s:function>
\par #*/
\par assertFalse()
\par \{
\par   _shunit_shouldSkip && return $\{SHUNIT_TRUE\}
\par 
\par   _su_message=''
\par   if [ $# -eq 2 ]; then
\par     _su_message=$1
\par     shift
\par   fi
\par   _su_condition=$\{1:-\}
\par 
\par   shunit_return=$\{SHUNIT_TRUE\}
\par 
\par   # see if condition is an integer, i.e. a return value
\par   _su_match=`expr "$\{_su_condition\}" : '\\([0-9]*\\)'`
\par   if [ -z "$\{_su_condition\}" ]; then
\par     # null condition
\par     shunit_return=$\{SHUNIT_FALSE\}
\par   elif [ "$\{_su_condition\}" = "$\{_su_match\}" ]; then
\par     # possible return value. treating 0 as true, and non-zero as false.
\par     [ $\{_su_condition\} -eq 0 ] && shunit_return=$\{SHUNIT_FALSE\}
\par   else
\par     # (hopefully) a condition
\par     ( eval $\{_su_condition\} ) >/dev/null 2>&1
\par     [ $? -eq 0 ] && shunit_return=$\{SHUNIT_FALSE\}
\par   fi
\par 
\par   # record the test
\par   if [ $\{shunit_return\} -eq $\{SHUNIT_TRUE\} ]; then
\par     _shunit_testPassed
\par   else
\par     _shunit_testFailed "$\{_su_message\}"
\par   fi
\par 
\par   unset _su_message _su_condition _su_match
\par   return $\{shunit_return\}
\par \}
\par 
\par #-----------------------------------------------------------------------------
\par # failure functions
\par #
\par 
\par #/**
\par # <s:function group="failures">
\par # <entry align="right">
\par #   <emphasis>void</emphasis>
\par # </entry>
\par # <entry>
\par #   <funcsynopsis>
\par #     <funcprototype>
\par #       <funcdef><function>fail</function></funcdef>
\par #       <paramdef>string <parameter>[message]</parameter></paramdef>
\par #     </funcprototype>
\par #   </funcsynopsis>
\par #   <para>Fails the test immediately, with the optional message.</para>
\par # </entry>
\par # </s:function>
\par #*/
\par fail()
\par \{
\par   _shunit_shouldSkip && return $\{SHUNIT_TRUE\}
\par 
\par   _su_message=$\{1:-\}
\par 
\par   _shunit_testFailed "$\{_su_message\}"
\par 
\par   unset _su_message
\par \}
\par 
\par #/**
\par # <s:function group="failures">
\par # <entry align="right">
\par #   <emphasis>void</emphasis>
\par # </entry>
\par # <entry>
\par #   <funcsynopsis>
\par #     <funcprototype>
\par #       <funcdef><function>failNotEquals</function></funcdef>
\par #       <paramdef>string <parameter>[message]</parameter></paramdef>
\par #       <paramdef>string <parameter>unexpected</parameter></paramdef>
\par #       <paramdef>string <parameter>actual</parameter></paramdef>
\par #     </funcprototype>
\par #   </funcsynopsis>
\par #   <para>Fails the test if <emphasis>unexpected</emphasis> and
\par #   <emphasis>actual</emphasis> are <emphasis role="strong">not</emphasis>
\par #   equal to one another. The message is optional.</para>
\par # </entry>
\par # </s:function>
\par #*/
\par failNotEquals()
\par \{
\par   _shunit_shouldSkip && return $\{SHUNIT_TRUE\}
\par 
\par   _su_message=''
\par   if [ $# -eq 3 ]; then
\par     _su_message=$1
\par     shift
\par   fi
\par   _su_unexpected=$\{1:-\}
\par   _su_actual=$\{2:-\}
\par 
\par   _shunit_testFailed "$\{_su_message:+$\{_su_message\} \}expected:<$\{_su_unexpected\}> but was:<$\{_su_actual\}>"
\par 
\par   unset _su_message _su_unexpected _su_actual
\par \}
\par 
\par #/**
\par # <s:function group="failures">
\par # <entry align="right">
\par #   <emphasis>void</emphasis>
\par # </entry>
\par # <entry>
\par #   <funcsynopsis>
\par #     <funcprototype>
\par #       <funcdef><function>failSame</function></funcdef>
\par #       <paramdef>string <parameter>[message]</parameter></paramdef>
\par #     </funcprototype>
\par #   </funcsynopsis>
\par #   <para>Indicate test failure because arguments were not the same. The
\par #   message is optional.</para>
\par # </entry>
\par # </s:function>
\par #*/
\par failSame()
\par \{
\par   _shunit_shouldSkip && return $\{SHUNIT_TRUE\}
\par 
\par   _su_message=$\{1:-\}
\par 
\par   _shunit_testFailed "$\{_su_message:+$\{_su_message\} \}expected not same"
\par 
\par   unset _su_message
\par \}
\par 
\par #/**
\par # <s:function group="failures">
\par # <entry align="right">
\par #   <emphasis>void</emphasis>
\par # </entry>
\par # <entry>
\par #   <funcsynopsis>
\par #     <funcprototype>
\par #       <funcdef><function>failNotSame</function></funcdef>
\par #       <paramdef>string <parameter>[message]</parameter></paramdef>
\par #       <paramdef>string <parameter>expected</parameter></paramdef>
\par #       <paramdef>string <parameter>actual</parameter></paramdef>
\par #     </funcprototype>
\par #   </funcsynopsis>
\par #   <para>Fails the test if <emphasis>expected</emphasis> and
\par #   <emphasis>actual</emphasis> are equal to one another. The message is
\par #   optional.</para>
\par # </entry>
\par # </s:function>
\par #*/
\par failNotSame()
\par \{
\par   failNotEquals "$\{@:-\}"
\par \}
\par 
\par #-----------------------------------------------------------------------------
\par # skipping functions
\par #
\par 
\par #/**
\par # <s:function group="skipping">
\par # <entry align="right">
\par #   <emphasis>void</emphasis>
\par # </entry>
\par # <entry>
\par #   <funcsynopsis>
\par #     <funcprototype>
\par #       <funcdef><function>startSkipping</function></funcdef>
\par #       <paramdef />
\par #     </funcprototype>
\par #   </funcsynopsis>
\par #   <para>This function forces the remaining assert and fail functions to be
\par #   "skipped", i.e. they will have no effect. Each function skipped will be
\par #   recorded so that the total of asserts and fails will not be altered.</para>
\par # </entry>
\par # </s:function>
\par #*/
\par startSkipping()
\par \{
\par   __shunit_skip=$\{SHUNIT_TRUE\}
\par \}
\par 
\par #/**
\par # <s:function group="skipping">
\par # <entry align="right">
\par #   <emphasis>void</emphasis>
\par # </entry>
\par # <entry>
\par #   <funcsynopsis>
\par #     <funcprototype>
\par #       <funcdef><function>endSkipping</function></funcdef>
\par #       <paramdef />
\par #     </funcprototype>
\par #   </funcsynopsis>
\par #   <para>This function returns calls to the assert and fail functions to their
\par #   default behavior, i.e. they will be called.</para>
\par # </entry>
\par # </s:function>
\par #*/
\par endSkipping()
\par \{
\par   __shunit_skip=$\{SHUNIT_FALSE\}
\par \}
\par 
\par #/**
\par # <s:function group="skipping">
\par # <entry align="right">
\par #   <emphasis>boolean</emphasis>
\par # </entry>
\par # <entry>
\par #   <funcsynopsis>
\par #     <funcprototype>
\par #       <funcdef><function>isSkipping</function></funcdef>
\par #       <paramdef />
\par #     </funcprototype>
\par #   </funcsynopsis>
\par #   <para>This function returns the state of skipping.</para>
\par # </entry>
\par # </s:function>
\par #*/
\par isSkipping()
\par \{
\par   return $\{__shunit_skip\}
\par \}
\par 
\par #-----------------------------------------------------------------------------
\par # suite functions
\par #
\par 
\par #/**
\par # <s:function group="suites">
\par # <entry align="right">
\par #   <emphasis>void</emphasis>
\par # </entry>
\par # <entry>
\par #   <funcsynopsis>
\par #     <funcprototype>
\par #       <funcdef><function>suite</function></funcdef>
\par #       <paramdef />
\par #     </funcprototype>
\par #   </funcsynopsis>
\par #   <para>This function can be optionally overridden by the user in their test
\par #   suite.</para>
\par #   <para>If this function exists, it will be called when
\par #   <command>shunit2</command> is sourced. If it does not exist, shUnit2 will
\par #   search the parent script for all functions beginning with the word
\par #   <literal>test</literal>, and they will be added dynamically to the test
\par #   suite.</para>
\par # </entry>
\par # </s:function>
\par #*/
\par # Note: see _shunit_mktempFunc() for actual implementation
\par # suite() \{ :; \}
\par 
\par #/**
\par # <s:function group="suites">
\par # <entry align="right">
\par #   <emphasis>void</emphasis>
\par # </entry>
\par # <entry>
\par #   <funcsynopsis>
\par #     <funcprototype>
\par #       <funcdef><function>suite_addTest</function></funcdef>
\par #       <paramdef>string <parameter>function</parameter></paramdef>
\par #     </funcprototype>
\par #   </funcsynopsis>
\par #   <para>This function adds a function name to the list of tests scheduled for
\par #   execution as part of this test suite. This function should only be called
\par #   from within the <function>suite()</function> function.</para>
\par # </entry>
\par # </s:function>
\par #*/
\par suite_addTest()
\par \{
\par   _su_func=$\{1:-\}
\par 
\par   __shunit_suite="$\{__shunit_suite:+$\{__shunit_suite\} \}$\{_su_func\}"
\par 
\par   unset _su_func
\par \}
\par 
\par #/**
\par # <s:function group="suites">
\par # <entry align="right">
\par #   <emphasis>void</emphasis>
\par # </entry>
\par # <entry>
\par #   <funcsynopsis>
\par #     <funcprototype>
\par #       <funcdef><function>oneTimeSetUp</function></funcdef>
\par #       <paramdef />
\par #     </funcprototype>
\par #   </funcsynopsis>
\par #   <para>This function can be be optionally overridden by the user in their
\par #   test suite.</para>
\par #   <para>If this function exists, it will be called once before any tests are
\par #   run. It is useful to prepare a common environment for all tests.</para>
\par # </entry>
\par # </s:function>
\par #*/
\par # Note: see _shunit_mktempFunc() for actual implementation
\par # oneTimeSetUp() \{ :; \}
\par 
\par #/**
\par # <s:function group="suites">
\par # <entry align="right">
\par #   <emphasis>void</emphasis>
\par # </entry>
\par # <entry>
\par #   <funcsynopsis>
\par #     <funcprototype>
\par #       <funcdef><function>oneTimeTearDown</function></funcdef>
\par #       <paramdef />
\par #     </funcprototype>
\par #   </funcsynopsis>
\par #   <para>This function can be be optionally overridden by the user in their
\par #   test suite.</para>
\par #   <para>If this function exists, it will be called once after all tests are
\par #   completed. It is useful to clean up the environment after all tests.</para>
\par # </entry>
\par # </s:function>
\par #*/
\par # Note: see _shunit_mktempFunc() for actual implementation
\par # oneTimeTearDown() \{ :; \}
\par 
\par #/**
\par # <s:function group="suites">
\par # <entry align="right">
\par #   <emphasis>void</emphasis>
\par # </entry>
\par # <entry>
\par #   <funcsynopsis>
\par #     <funcprototype>
\par #       <funcdef><function>setUp</function></funcdef>
\par #       <paramdef />
\par #     </funcprototype>
\par #   </funcsynopsis>
\par #   <para>This function can be be optionally overridden by the user in their
\par #   test suite.</para>
\par #   <para>If this function exists, it will be called before each test is run.
\par #   It is useful to reset the environment before each test.</para>
\par # </entry>
\par # </s:function>
\par #*/
\par # Note: see _shunit_mktempFunc() for actual implementation
\par # setUp() \{ :; \}
\par 
\par #/**
\par # <s:function group="suites">
\par # <entry align="right">
\par #   <emphasis>void</emphasis>
\par # </entry>
\par # <entry>
\par #   <funcsynopsis>
\par #     <funcprototype>
\par #       <funcdef><function>tearDown</function></funcdef>
\par #       <paramdef />
\par #     </funcprototype>
\par #   </funcsynopsis>
\par #   <para>This function can be be optionally overridden by the user in their
\par #   test suite.</para>
\par #   <para>If this function exists, it will be called after each test completes.
\par #   It is useful to clean up the environment after each test.</para>
\par # </entry>
\par # </s:function>
\par #*/
\par # Note: see _shunit_mktempFunc() for actual implementation
\par # tearDown() \{ :; \}
\par 
\par #------------------------------------------------------------------------------
\par # internal shUnit2 functions
\par #
\par 
\par _shunit_cleanup()
\par \{
\par   name=$1
\par 
\par   case $\{name\} in
\par     EXIT) signal=0 ;;
\par     INT) signal=2 ;;
\par     TERM) signal=15 ;;
\par     *)
\par       _shunit_warn "unrecognized trap value ($\{name\})"
\par       signal=0
\par       ;;
\par   esac
\par 
\par   # do our work
\par   rm -fr "$\{__shunit_tmpDir\}"
\par 
\par   # exit for all non-EXIT signals
\par   if [ $\{name\} != 'EXIT' ]; then
\par     _shunit_warn "trapped and now handling the ($\{name\}) signal"
\par     _shunit_generateReport
\par     # disable EXIT trap
\par     trap 0
\par     # add 127 to signal and exit
\par     signal=`expr $\{signal\} + 127`
\par     exit $\{signal\}
\par   fi
\par \}
\par 
\par _shunit_execSuite()
\par \{
\par   echo '#'
\par   echo '# Performing tests'
\par   echo '#'
\par   for _su_func in $\{__shunit_suite\}; do
\par     # disable skipping
\par     endSkipping
\par 
\par     # execute the per-test setup function
\par     setUp
\par 
\par     # execute the test
\par     echo "$\{_su_func\}"
\par     eval $\{_su_func\}
\par 
\par     # execute the per-test tear-down function
\par     tearDown
\par   done
\par 
\par   unset _su_func
\par \}
\par 
\par _shunit_functionExists()
\par \{
\par   _su__func=$1
\par   type $\{_su__func\} 2>/dev/null |grep "is a function$" >/dev/null
\par   _su__return=$?
\par   unset _su__func
\par   return $\{_su__return\}
\par \}
\par 
\par _shunit_generateReport()
\par \{
\par   _su__awkPercent='\{printf("%4d %3.0f%%", $1, $1*100/$2)\}'
\par   if [ $\{__shunit_testsTotal:-0\} -gt 0 ]; then
\par     _su__passed=`echo $\{__shunit_testsPassed\} $\{__shunit_testsTotal\} |\\
\par         awk "$\{_su__awkPercent\}"`
\par     _su__failed=`echo $\{__shunit_testsFailed\} $\{__shunit_testsTotal\} |\\
\par         awk "$\{_su__awkPercent\}"`
\par     _su__skipped=`echo $\{__shunit_testsSkipped\} $\{__shunit_testsTotal\} |\\
\par         awk "$\{_su__awkPercent\}"`
\par     _su__total=`echo $\{__shunit_testsTotal\} 100 |\\
\par         awk '\{printf("%4d %3d%%", $1, $2)\}'`
\par   else
\par     _su__passed=`echo 0 0 |awk '\{printf("%4d %3d%%", $1, $2)\}'`
\par     _su__failed=$\{_su__passed\}
\par     _su__skipped=$\{_su__passed\}
\par     _su__total=$\{_su__passed\}
\par   fi
\par 
\par   cat <<EOF
\par 
\par #
\par # Test report
\par #
\par tests passed:  $\{_su__passed\}
\par tests failed:  $\{_su__failed\}
\par tests skipped: $\{_su__skipped\}
\par tests total:   $\{_su__total\}
\par EOF
\par 
\par   unset _su__awkPercent _su__passed _su__failed _su__skipped _su__total
\par \}
\par 
\par # this function is a cross-platform temporary directory creation tool. not all
\par # OSes have the mktemp function, so one is included here.
\par _shunit_mktempDir()
\par \{
\par   # try the standard mktemp function
\par   ( exec mktemp -dqt shunit.XXXXXX 2>/dev/null ) && return
\par 
\par   # the standard mktemp didn't work.  doing our own.
\par   if [ -r '/dev/urandom' ]; then
\par     _su__random=`od -vAn -N4 -tx4 </dev/urandom |sed 's/^[^0-9a-f]*//'`
\par   elif [ -n "$\{RANDOM:-\}" ]; then
\par     # $RANDOM works
\par     _su__random=$\{RANDOM\}$\{RANDOM\}$\{RANDOM\}$$
\par   else
\par     # $RANDOM doesn't work
\par     _su__date=`date '+%Y%m%d%H%M%S'`
\par     _su__random=`expr $\{_su__date\} / $$`
\par   fi
\par 
\par   _su__tmpDir="$\{TMPDIR-/tmp\}/shunit.$\{_su__random\}"
\par   ( umask 077 && mkdir "$\{_su__tmpDir\}" ) || \{
\par     echo 'shUnit:FATAL could not create temporary directory! exiting' >&2
\par     exit 1
\par   \}
\par 
\par   echo $\{_su__tmpDir\}
\par   unset _su__date _su__random _su__tmpDir
\par \}
\par 
\par # this function is here to work around issues in Cygwin
\par _shunit_mktempFunc()
\par \{
\par   for _su__func in oneTimeSetUp oneTimeTearDown setUp tearDown suite; do
\par     _su__file="$\{__shunit_tmpDir\}/$\{_su__func\}"
\par     cat <<EOF >"$\{_su__file\}"
\par #! /bin/sh
\par exit 0
\par EOF
\par     chmod +x "$\{_su__file\}"
\par   done
\par 
\par   unset _su__file
\par \}
\par 
\par _shunit_shouldSkip()
\par \{
\par   [ $\{__shunit_skip\} -eq $\{SHUNIT_FALSE\} ] && return $\{SHUNIT_FALSE\}
\par   _shunit_testSkipped
\par \}
\par 
\par _shunit_testPassed()
\par \{
\par   __shunit_testsPassed=`expr $\{__shunit_testsPassed\} + 1`
\par   __shunit_testsTotal=`expr $\{__shunit_testsTotal\} + 1`
\par \}
\par 
\par _shunit_testFailed()
\par \{
\par   _su__msg=$1
\par 
\par   __shunit_testsFailed=`expr $\{__shunit_testsFailed\} + 1`
\par   __shunit_testsTotal=`expr $\{__shunit_testsTotal\} + 1`
\par   echo "$\{__SHUNIT_ASSERT_MSG_PREFIX\}$\{_su__msg\}" >&2
\par 
\par   unset _su__msg
\par \}
\par 
\par _shunit_testSkipped()
\par \{
\par   __shunit_testsSkipped=`expr $\{__shunit_testsSkipped\} + 1`
\par   __shunit_testsTotal=`expr $\{__shunit_testsTotal\} + 1`
\par \}
\par 
\par #------------------------------------------------------------------------------
\par # main
\par #
\par 
\par # create a temporary storage location
\par __shunit_tmpDir=`_shunit_mktempDir`
\par 
\par # setup traps to clean up after ourselves
\par trap '_shunit_cleanup EXIT' 0
\par trap '_shunit_cleanup INT' 2
\par trap '_shunit_cleanup TERM' 15
\par 
\par # create phantom functions to work around issues with Cygwin
\par _shunit_mktempFunc
\par PATH="$\{__shunit_tmpDir\}:$\{PATH\}"
\par 
\par # execute the oneTimeSetUp function (if it exists)
\par #_shunit_functionExists oneTimeSetUp && oneTimeSetUp
\par oneTimeSetUp
\par 
\par # execute the suite function defined in the parent test script
\par # deprecated as of 2.1.0
\par suite
\par 
\par # if no suite function was defined, dynamically build a list of functions
\par if [ -z "$\{__shunit_suite\}" ]; then
\par   funcs=`grep "^[ \\t]*test[A-Za-z0-9_]* *()" $\{__SHUNIT_PARENT\} \\
\par       |sed 's/[^A-Za-z0-9_]//g'`
\par   for func in $\{funcs\}; do
\par     suite_addTest $\{func\}
\par   done
\par fi
\par 
\par # execute the tests
\par _shunit_execSuite
\par 
\par # execute the oneTimeTearDown function (if it exists)
\par oneTimeTearDown
\par 
\par # generate report
\par _shunit_generateReport
\par 
\par # restore the previous set of shell flags
\par for _shunit_shellFlag in $\{__SHUNIT_SHELL_FLAGS\}; do
\par   echo $\{_shunit_shellFlags\} |grep $\{_shunit_shellFlag\} >/dev/null \\
\par     || set +$\{_shunit_shellFlag\}
\par done
\par unset _shunit_shellFlag _shunit_shellFlags
\par 
\par [ $\{__shunit_testsFailed\} -eq 0 ] || exit 1
\par 
\par #/**
\par # </s:shelldoc>
\par #*/\par}