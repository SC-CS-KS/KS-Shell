{\rtf1\fbidis\ansi\ansicpg0\uc1\deff0\deflang0\deflangfe0{\fonttbl{\f0\fnil \'cb\'ce\'cc\'e5;}{\f1\fnil \'ce\'a2\'c8\'ed\'d1\'c5\'ba\'da;}{\f2\fnil\fcharset134 \'cb\'ce\'cc\'e5;}{\f3\fnil Arial;}{\f4\fnil\fcharset2 Symbol;}{\f5\fnil\fcharset0 Courier New;}}{\colortbl;\red0\green0\blue255;\red0\green0\blue0;\red255\green255\blue255;}{\*\listtable{\list\listtemplateid1252610437\listsimple1
{\listlevel\levelnfc23\leveljc0\li720\fi-360\jclisttab\tx720{\leveltext\'00;}{\levelnumbers;}\f3\fs24}
\listid2139598749}
{\list\listtemplateid1697130520\listsimple1
{\listlevel\levelnfc23\leveljc0\li720\fi-360\jclisttab\tx720{\leveltext\'00;}{\levelnumbers;}\f3\fs24}
\listid926788733}
{\list\listtemplateid823202931\listsimple1
{\listlevel\levelnfc23\leveljc0\li720\fi-360\jclisttab\tx720{\leveltext\'00;}{\levelnumbers;}\f3\fs24}
\listid125908548}
{\list\listtemplateid463823190
{\listlevel\levelnfc23\leveljc0\li720\fi-360\jclisttab\tx720{\leveltext\'01\uc2\u183 \'a1\'a4\uc1;}{\levelnumbers;}\f4\fs24\lang1024}
{\listlevel\levelnfc23\leveljc0\li1080\fi-360\jclisttab\tx1080{\leveltext\'01o;}{\levelnumbers;}\f5\fs24}
{\listlevel\levelnfc23\leveljc0\li1080\fi-360\jclisttab\tx1080{\leveltext\'01o;}{\levelnumbers;}\f5\fs24}
{\listlevel\levelnfc23\leveljc0\li1080\fi-360\jclisttab\tx1080{\leveltext\'01o;}{\levelnumbers;}\f5\fs24}
{\listlevel\levelnfc23\leveljc0\li1080\fi-360\jclisttab\tx1080{\leveltext\'01o;}{\levelnumbers;}\f5\fs24}
{\listlevel\levelnfc23\leveljc0\li1080\fi-360\jclisttab\tx1080{\leveltext\'01o;}{\levelnumbers;}\f5\fs24}
{\listlevel\levelnfc23\leveljc0\li1080\fi-360\jclisttab\tx1080{\leveltext\'01o;}{\levelnumbers;}\f5\fs24}
{\listlevel\levelnfc23\leveljc0\li1080\fi-360\jclisttab\tx1080{\leveltext\'01o;}{\levelnumbers;}\f5\fs24}
{\listlevel\levelnfc23\leveljc0\li1080\fi-360\jclisttab\tx1080{\leveltext\'01o;}{\levelnumbers;}\f5\fs24}
\listid321110707}
{\list\listtemplateid28531585\listsimple1
{\listlevel\levelnfc23\leveljc0\li720\fi-360\jclisttab\tx720{\leveltext\'00;}{\levelnumbers;}\f3\fs24}
\listid1874841993}
{\list\listtemplateid1998487988
{\listlevel\levelnfc23\leveljc0\li720\fi-360\jclisttab\tx720{\leveltext\'01\uc2\u183 \'a1\'a4\uc1;}{\levelnumbers;}\f4\fs24\lang1024}
{\listlevel\levelnfc23\leveljc0\li1080\fi-360\jclisttab\tx1080{\leveltext\'01o;}{\levelnumbers;}\f5\fs24}
{\listlevel\levelnfc23\leveljc0\li1080\fi-360\jclisttab\tx1080{\leveltext\'01o;}{\levelnumbers;}\f5\fs24}
{\listlevel\levelnfc23\leveljc0\li1080\fi-360\jclisttab\tx1080{\leveltext\'01o;}{\levelnumbers;}\f5\fs24}
{\listlevel\levelnfc23\leveljc0\li1080\fi-360\jclisttab\tx1080{\leveltext\'01o;}{\levelnumbers;}\f5\fs24}
{\listlevel\levelnfc23\leveljc0\li1080\fi-360\jclisttab\tx1080{\leveltext\'01o;}{\levelnumbers;}\f5\fs24}
{\listlevel\levelnfc23\leveljc0\li1080\fi-360\jclisttab\tx1080{\leveltext\'01o;}{\levelnumbers;}\f5\fs24}
{\listlevel\levelnfc23\leveljc0\li1080\fi-360\jclisttab\tx1080{\leveltext\'01o;}{\levelnumbers;}\f5\fs24}
{\listlevel\levelnfc23\leveljc0\li1080\fi-360\jclisttab\tx1080{\leveltext\'01o;}{\levelnumbers;}\f5\fs24}
\listid1143069832}
{\list\listtemplateid2058106031\listsimple1
{\listlevel\levelnfc23\leveljc0\li720\fi-360\jclisttab\tx720{\leveltext\'00;}{\levelnumbers;}\f3\fs24}
\listid1443350383}
}
{\*\listoverridetable
{\listoverride\listid2139598749\listoverridecount0\ls1}
{\listoverride\listid926788733\listoverridecount0\ls2}
{\listoverride\listid125908548\listoverridecount0\ls3}
{\listoverride\listid321110707\listoverridecount0\ls4}
{\listoverride\listid1874841993\listoverridecount0\ls5}
{\listoverride\listid1143069832\listoverridecount0\ls6}
{\listoverride\listid1443350383\listoverridecount0\ls7}
}


\pard\fi0\li0\qc\ri0\sb0\sa0\itap0 \plain \f2\b\lang2052\fs24\cf2 /etc/init.d/function
\par \pard\fi0\li0\ql\ri0\sb0\sa0\itap0 
\par \plain \f1\fs20 # -*-Shell-script-*-
\par #
\par # \plain \f1\fs20\cf1 functions     This file contains functions to be used by most or all
\par \plain \f1\fs20 #               \plain \f1\fs20\cf1 shell scripts in the /etc/init.d directory.
\par \plain \f1\fs20 #
\par 
\par \plain \f1\fs20\cf1 TEXTDOMAIN=initscripts
\par \plain \f1\fs20 
\par # Make sure umask is sane
\par \plain \f1\fs20\cf1 umask 022
\par \plain \f1\fs20 
\par # Set up a default search path.
\par \plain \f1\fs20\cf1 PATH="/sbin:/usr/sbin:/bin:/usr/bin:/usr/X11R6/bin"
\par export PATH
\par \plain \f1\fs20 
\par # Get a sane screen width
\par [ -z "$\{COLUMNS:-\}" ] && COLUMNS=80
\par 
\par [ -z "$\{CONSOLETYPE:-\}" ] && CONSOLETYPE="`/sbin/consoletype`"
\par 
\par if [ -f /etc/sysconfig/i18n -a -z "$\{NOLOCALE:-\}" ] ; then
\par   . /etc/sysconfig/i18n
\par   if [ "$CONSOLETYPE" != "pty" ]; then
\par         case "$\{LANG:-\}" in
\par                 ja_JP*|ko_KR*|zh_CN*|zh_TW*|bn_*|bd_*|pa_*|hi_*|ta_*|gu_*)
\par                         export LC_MESSAGES=en_US
\par                         export LANG
\par                         ;;
\par                 *)
\par                         export LANG
\par                         ;;
\par         esac
\par   else
\par         [ -n "$LC_MESSAGES" ] && export LC_MESSAGES
\par         export LANG
\par   fi
\par fi
\par 
\par # Read in our configuration
\par if [ -z "$\{BOOTUP:-\}" ]; then
\par   if [ -f /etc/sysconfig/init ]; then
\par       . /etc/sysconfig/init
\par   else
\par     # This all seem confusing? Look in /etc/sysconfig/init,
\par     # or in /usr/doc/initscripts-*/sysconfig.txt
\par     BOOTUP=color
\par     RES_COL=60
\par     MOVE_TO_COL="echo -en \\\\033[$\{RES_COL\}G"
\par     SETCOLOR_SUCCESS="echo -en \\\\033[1;32m"
\par     SETCOLOR_FAILURE="echo -en \\\\033[1;31m"
\par     SETCOLOR_WARNING="echo -en \\\\033[1;33m"
\par     SETCOLOR_NORMAL="echo -en \\\\033[0;39m"
\par     LOGLEVEL=1
\par   fi
\par   if [ "$CONSOLETYPE" = "serial" ]; then
\par       BOOTUP=serial
\par       MOVE_TO_COL=
\par       SETCOLOR_SUCCESS=
\par       SETCOLOR_FAILURE=
\par       SETCOLOR_WARNING=
\par       SETCOLOR_NORMAL=
\par   fi
\par fi
\par 
\par if [ "$\{BOOTUP:-\}" != "verbose" ]; then
\par    INITLOG_ARGS="-q"
\par else
\par    INITLOG_ARGS=
\par fi
\par 
\par # Check if $pid (could be plural) are running
\par checkpid() \{
\par         local i
\par 
\par         for i in $* ; do
\par                 [ -d "/proc/$i" ] && return 0
\par         done
\par         return 1
\par \}
\par 
\par 
\par \plain \f1\fs20\cf1 # A function to start a program.
\par \plain \f1\b\fs20\cf1 daemon\plain \f1\fs20 () \{
\par         # Test syntax.
\par         local gotbase= force=
\par         local base= user= nice= bg= pid=
\par         nicelevel=0
\par         while [ "$1" != "$\{1##[-+]\}" ]; do
\par           case $1 in
\par             '')    echo $"$0: Usage: daemon [+/-nicelevel] \{program\}"
\par                    return 1;;
\par             --check)
\par                    base=$2
\par                    gotbase="yes"
\par                    shift 2
\par                    ;;
\par             --check=?*)
\par                    base=$\{1#--check=\}
\par                    gotbase="yes"
\par                    shift
\par                    ;;
\par             --user)
\par                    user=$2
\par                    shift 2
\par                    ;;
\par             --user=?*)
\par                    user=$\{1#--user=\}
\par                    shift
\par                    ;;
\par             --force)
\par                    force="force"
\par                    shift
\par                    ;;
\par             [-+][0-9]*)
\par                    nice="nice -n $1"
\par                    shift
\par                    ;;
\par             *)     echo $"$0: Usage: daemon [+/-nicelevel] \{program\}"
\par                    return 1;;
\par           esac
\par         done
\par 
\par         # Save basename.
\par         [ -z "$gotbase" ] && base=$\{1##*/\}
\par 
\par         # See if it's already running. Look *only* at the pid file.
\par         if [ -f /var/run/$\{base\}.pid ]; then
\par                 local line p
\par                 read line < /var/run/$\{base\}.pid
\par                 for p in $line ; do
\par                         [ -z "$\{p//[0-9]/\}" -a -d "/proc/$p" ] && pid="$pid $p"
\par                 done
\par         fi
\par 
\par         [ -n "$\{pid:-\}" -a -z "$\{force:-\}" ] && return
\par 
\par         # make sure it doesn't core dump anywhere unless requested
\par         ulimit -S -c $\{DAEMON_COREFILE_LIMIT:-0\} >/dev/null 2>&1
\par 
\par         # if they set NICELEVEL in /etc/sysconfig/foo, honor it
\par         [ -n "$NICELEVEL" ] && nice="nice -n $NICELEVEL"
\par 
\par         # Echo daemon
\par         [ "$\{BOOTUP:-\}" = "verbose" -a -z "$LSB" ] && echo -n " $base"
\par 
\par         # And start it up.
\par         if [ -z "$user" ]; then
\par            $nice initlog $INITLOG_ARGS -c "$*"
\par         else
\par            $nice initlog $INITLOG_ARGS -c "runuser -s /bin/bash - $user -c \\"$*\\""
\par         fi
\par         [ "$?" -eq 0 ] && success $"$base startup" || failure $"$base startup"
\par \}
\par 
\par \plain \f1\fs20\cf1 # A function to stop a program.
\par \plain \f1\b\fs20\cf1 killproc\plain \f1\fs20\cf1 () \{
\par \plain \f1\fs20         RC=0
\par         # Test syntax.
\par         if [ "$#" -eq 0 ]; then
\par                 echo $"Usage: killproc \{program\} [signal]"
\par                 return 1
\par         fi
\par 
\par         notset=0
\par         # check for second arg to be kill level
\par         if [ -n "$2" ]; then
\par                 killlevel=$2
\par         else
\par                 notset=1
\par                 killlevel="-9"
\par         fi
\par 
\par         # Save basename.
\par         base=$\{1##*/\}
\par 
\par         # Find pid.
\par         pid=
\par         if [ -f /var/run/$\{base\}.pid ]; then
\par                 local line p
\par                 read line < /var/run/$\{base\}.pid
\par                 for p in $line ; do
\par                         [ -z "$\{p//[0-9]/\}" -a -d "/proc/$p" ] && pid="$pid $p"
\par                 done
\par         fi
\par         if [ -z "$pid" ]; then
\par                 pid=`pidof -o $$ -o $PPID -o %PPID -x $1 || \\
\par                         pidof -o $$ -o $PPID -o %PPID -x $base`
\par         fi
\par 
\par         # Kill it.
\par         if [ -n "$\{pid:-\}" ] ; then
\par                 [ "$BOOTUP" = "verbose" -a -z "$LSB" ] && echo -n "$base "
\par                 if [ "$notset" -eq "1" ] ; then
\par                        if checkpid $pid 2>&1; then
\par                            # TERM first, then KILL if not dead
\par                            kill -TERM $pid >/dev/null 2>&1
\par                            usleep 100000
\par                            if checkpid $pid && sleep 1 &&
\par                               checkpid $pid && sleep 3 &&
\par                               checkpid $pid ; then
\par                                 kill -KILL $pid >/dev/null 2>&1
\par                                 usleep 100000
\par                            fi
\par                         fi
\par                         checkpid $pid
\par                         RC=$?
\par                         [ "$RC" -eq 0 ] && failure $"$base shutdown" || success $"$base shutdown"
\par                         RC=$((! $RC))
\par                 # use specified level only
\par                 else
\par                         if checkpid $pid; then
\par                                 kill $killlevel $pid >/dev/null 2>&1
\par                                 RC=$?
\par                                 [ "$RC" -eq 0 ] && success $"$base $killlevel" || failure $"$base $killlevel"
\par                         fi
\par                 fi
\par         else
\par             failure $"$base shutdown"
\par             RC=1
\par         fi
\par 
\par         # Remove pid file if any.
\par         if [ "$notset" = "1" ]; then
\par             rm -f /var/run/$base.pid
\par         fi
\par         return $RC
\par \}
\par 
\par \plain \f1\fs20\cf1 # A function to find the pid of a program. Looks *only* at the pidfile
\par \plain \f1\b\fs20 pidfileofproc\plain \f1\fs20 () \{
\par         local base=$\{1##*/\}
\par 
\par         # Test syntax.
\par         if [ "$#" = 0 ] ; then
\par                 echo $"Usage: pidfileofproc \{program\}"
\par                 return 1
\par         fi
\par 
\par         # First try "/var/run/*.pid" files
\par         if [ -f /var/run/$base.pid ] ; then
\par                 local line p pid=
\par                 read line < /var/run/$base.pid
\par                 for p in $line ; do
\par                        [ -z "$\{p//[0-9]/\}" -a -d /proc/$p ] && pid="$pid $p"
\par                 done
\par                 if [ -n "$pid" ]; then
\par                         echo $pid
\par                         return 0
\par                 fi
\par         fi
\par \}
\par 
\par \plain \f1\fs20\cf1 # A function to find the pid of a program.
\par \plain \f1\b\fs20\cf1 pidofproc\plain \f1\fs20\cf1 () \{
\par \plain \f1\fs20         base=$\{1##*/\}
\par 
\par         # Test syntax.
\par         if [ "$#" = 0 ]; then
\par                 echo $"Usage: pidofproc \{program\}"
\par                 return 1
\par         fi
\par 
\par         # First try "/var/run/*.pid" files
\par         if [ -f /var/run/$base.pid ]; then
\par                 local line p pid=
\par                 read line < /var/run/$base.pid
\par                 for p in $line ; do
\par                        [ -z "$\{p//[0-9]/\}" -a -d /proc/$p ] && pid="$pid $p"
\par                 done
\par                 if [ -n "$pid" ]; then
\par                         echo $pid
\par                         return 0
\par                 fi
\par         fi
\par         pidof -o $$ -o $PPID -o %PPID -x $1 || \\
\par                 pidof -o $$ -o $PPID -o %PPID -x $base
\par \}
\par 
\par \plain \f1\b\fs20\cf1 status\plain \f1\fs20\cf1 () \{
\par \plain \f1\fs20         local base=$\{1##*/\}
\par         local pid
\par 
\par         # Test syntax.
\par         if [ "$#" = 0 ] ; then
\par                 echo $"Usage: status \{program\}"
\par                 return 1
\par         fi
\par 
\par         # First try "pidof"
\par         pid=`pidof -o $$ -o $PPID -o %PPID -x $1 || \\
\par              pidof -o $$ -o $PPID -o %PPID -x $\{base\}`
\par         if [ -n "$pid" ]; then
\par                 echo $"$\{base\} (pid $pid) is running..."
\par                 return 0
\par         fi
\par 
\par         # Next try "/var/run/*.pid" files
\par         if [ -f /var/run/$\{base\}.pid ] ; then
\par                 read pid < /var/run/$\{base\}.pid
\par                 if [ -n "$pid" ]; then
\par                         echo $"$\{base\} dead but pid file exists"
\par                         return 1
\par                 fi
\par         fi
\par         # See if /var/lock/subsys/$\{base\} exists
\par         if [ -f /var/lock/subsys/$\{base\} ]; then
\par                 echo $"$\{base\} dead but subsys locked"
\par                 return 2
\par         fi
\par         echo $"$\{base\} is stopped"
\par         return 3
\par \}
\par 
\par \plain \f1\b\fs20\cf1 echo_success\plain \f1\fs20\cf1 () \{
\par \plain \f1\fs20   [ "$BOOTUP" = "color" ] && $MOVE_TO_COL
\par   echo -n "[  "
\par   [ "$BOOTUP" = "color" ] && $SETCOLOR_SUCCESS
\par   echo -n $"OK"
\par   [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
\par   echo -n "  ]"
\par   echo -ne "\\r"
\par   return 0
\par \}
\par 
\par \plain \f1\b\fs20\cf1 echo_failure\plain \f1\fs20\cf1 () \{
\par \plain \f1\fs20   [ "$BOOTUP" = "color" ] && $MOVE_TO_COL
\par   echo -n "["
\par   [ "$BOOTUP" = "color" ] && $SETCOLOR_FAILURE
\par   echo -n $"FAILED"
\par   [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
\par   echo -n "]"
\par   echo -ne "\\r"
\par   return 1
\par \}
\par 
\par \plain \f1\b\fs20\cf1 echo_passed\plain \f1\fs20\cf1 () \{
\par \plain \f1\fs20   [ "$BOOTUP" = "color" ] && $MOVE_TO_COL
\par   echo -n "["
\par   [ "$BOOTUP" = "color" ] && $SETCOLOR_WARNING
\par   echo -n $"PASSED"
\par   [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
\par   echo -n "]"
\par   echo -ne "\\r"
\par   return 1
\par \}
\par 
\par \plain \f1\b\fs20\cf1 echo_warning\plain \f1\fs20\cf1 () \{
\par \plain \f1\fs20   [ "$BOOTUP" = "color" ] && $MOVE_TO_COL
\par   echo -n "["
\par   [ "$BOOTUP" = "color" ] && $SETCOLOR_WARNING
\par   echo -n $"WARNING"
\par   [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
\par   echo -n "]"
\par   echo -ne "\\r"
\par   return 1
\par \}
\par 
\par \plain \f1\fs20\cf1 # Inform the graphical boot of our current state
\par \plain \f1\b\fs20\cf1 update_boot_stage\plain \f1\fs20\cf1 () \{
\par \plain \f1\fs20   if [ "$GRAPHICAL" = "yes" -a -x /usr/bin/rhgb-client ]; then
\par     /usr/bin/rhgb-client --update="$1"
\par   fi
\par   return 0
\par \}
\par 
\par \plain \f1\fs20\cf1 # Log that something succeeded
\par \plain \f1\b\fs20\cf1 success\plain \f1\fs20\cf1 () \{
\par \plain \f1\fs20   if [ -z "$\{IN_INITLOG:-\}" ]; then
\par      initlog $INITLOG_ARGS -n $0 -s "$1" -e 1
\par   else
\par      # silly hack to avoid EPIPE killing rc.sysinit
\par      trap "" SIGPIPE
\par      echo "$INITLOG_ARGS -n $0 -s \\"$1\\" -e 1" >&21
\par      trap - SIGPIPE
\par   fi
\par   [ "$BOOTUP" != "verbose" -a -z "$LSB" ] && echo_success
\par   return 0
\par \}
\par 
\par \plain \f1\fs20\cf1 # Log that something failed
\par \plain \f1\b\fs20\cf1 failure\plain \f1\fs20\cf1 () \{
\par \plain \f1\fs20   rc=$?
\par   if [ -z "$\{IN_INITLOG:-\}" ]; then
\par      initlog $INITLOG_ARGS -n $0 -s "$1" -e 2
\par   else
\par      trap "" SIGPIPE
\par      echo "$INITLOG_ARGS -n $0 -s \\"$1\\" -e 2" >&21
\par      trap - SIGPIPE
\par   fi
\par   [ "$BOOTUP" != "verbose" -a -z "$LSB" ] && echo_failure
\par   [ -x /usr/bin/rhgb-client ] && /usr/bin/rhgb-client --details=yes
\par   return $rc
\par \}
\par 
\par \plain \f1\fs20\cf1 # Log that something passed, but may have had errors. Useful for fsck
\par \plain \f1\b\fs20 passed\plain \f1\fs20 () \{
\par   rc=$?
\par   if [ -z "$\{IN_INITLOG:-\}" ]; then
\par      initlog $INITLOG_ARGS -n $0 -s "$1" -e 1
\par   else
\par      trap "" SIGPIPE
\par      echo "$INITLOG_ARGS -n $0 -s \\"$1\\" -e 1" >&21
\par      trap - SIGPIPE
\par   fi
\par   [ "$BOOTUP" != "verbose" -a -z "$LSB" ] && echo_passed
\par   return $rc
\par \}  
\par 
\par \plain \f1\fs20\cf1 # Log a warning
\par \plain \f1\b\fs20\cf1 warning\plain \f1\fs20\cf1 () \{
\par \plain \f1\fs20   rc=$?
\par   if [ -z "$\{IN_INITLOG:-\}" ]; then
\par      initlog $INITLOG_ARGS -n $0 -s "$1" -e 1
\par   else
\par      trap "" SIGPIPE
\par      echo "$INITLOG_ARGS -n $0 -s \\"$1\\" -e 1" >&21
\par      trap - SIGPIPE
\par   fi
\par   [ "$BOOTUP" != "verbose" -a -z "$LSB" ] && echo_warning
\par   return $rc
\par \}  
\par 
\par \plain \f1\fs20\cf1 # Run some action. Log its output.
\par \plain \f1\b\fs20 action\plain \f1\fs20 () \{
\par   STRING=$1
\par   echo -n "$STRING "
\par   if [ "$\{RHGB_STARTED\}" != "" -a -w /etc/rhgb/temp/rhgb-console ]; then
\par       echo -n "$STRING " > /etc/rhgb/temp/rhgb-console
\par   fi
\par   shift
\par   initlog $INITLOG_ARGS -c "$*" && success $"$STRING" || failure $"$STRING"
\par   rc=$?
\par   echo
\par   if [ "$\{RHGB_STARTED\}" != "" -a -w /etc/rhgb/temp/rhgb-console ]; then
\par       if [ "$rc" = "0" ]; then
\par         echo_success > /etc/rhgb/temp/rhgb-console
\par       else
\par         echo_failure > /etc/rhgb/temp/rhgb-console
\par         [ -x /usr/bin/rhgb-client ] && /usr/bin/rhgb-client --details=yes
\par       fi
\par       echo
\par   fi
\par   return $rc
\par \}
\par 
\par \plain \f1\fs20\cf1 # returns OK if $1 contains $2
\par \plain \f1\b\fs20\cf1 strstr\plain \f1\fs20\cf1 () \{
\par \plain \f1\fs20   [ "$\{1#*$2*\}" = "$1" ] && return 1
\par   return 0
\par \}
\par 
\par \plain \f1\fs20\cf1 # Confirm whether we really want to run this service
\par \plain \f1\b\fs20\cf1 confirm\plain \f1\fs20\cf1 () \{
\par \plain \f1\fs20   [ -x /usr/bin/rhgb-client ] && /usr/bin/rhgb-client --details=yes
\par   while : ; do 
\par       echo -n $"Start service $1 (Y)es/(N)o/(C)ontinue? [Y] "
\par       read answer
\par       if strstr $"yY" "$answer" || [ "$answer" = "" ] ; then
\par          return 0
\par       elif strstr $"cC" "$answer" ; then
\par          rm -f /var/run/confirm
\par          [ -x /usr/bin/rhgb-client ] && /usr/bin/rhgb-client --details=no
\par          return 2
\par       elif strstr $"nN" "$answer" ; then
\par          return 1
\par       fi
\par   done
\par \}\par}